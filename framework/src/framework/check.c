
/**
 * @file check.c
 *
 * Functions needed by check.
 * 
 * THIS FILE HAS BEEN GENERATED USING 
 * $Id: check.c.xsl 14618 2006-02-28 16:08:17Z                                jhb $.
 * DO NOT EDIT THIS FILE AS MIGHT BE CHANGED IN A LATER VERSION.
 *
 * ALL CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN!
 *
 */

/**
 * @defgroup check Check tree Functions
 *
 * Functions needed by check traversal.
 *
 * @{
 */


#include "check.h"
#include "globals.h"
#include "tree_basic.h"
#include "traverse.h"
#include "dbug.h"
#include "print.h"
#include "check_lib.h"
#include "free.h"
#include "str.h"
#include "memory.h"

/*****************************************************************************
 *
 * @fn node *CHKdoTreeCheck( node *syntax_tree)
 *
 ****************************************************************************/
node *
CHKdoTreeCheck (node * syntax_tree)
{
  DBUG_ENTER ("CHKdoTreeCheck");

  DBUG_PRINT ("CHK", ("Starting the check mechanism"));

  TRAVpush (TR_chk);
  syntax_tree = TRAVdo (syntax_tree, NULL);
  TRAVpop ();

  DBUG_PRINT ("CHK", ("Checkmechanism complete"));

  DBUG_RETURN (syntax_tree);
}

static bool
isBlock (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_enclosedblock) ||
	      (NODE_TYPE (arg_node) == N_statement));
  return (res);
}

static bool
isCodeBlock (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_fundec) ||
	      (NODE_TYPE (arg_node) == N_fundef) ||
	      (NODE_TYPE (arg_node) == N_globaldec) ||
	      (NODE_TYPE (arg_node) == N_globaldef));
  return (res);
}

static bool
isExpr (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_binop) ||
	      (NODE_TYPE (arg_node) == N_cast) ||
	      (NODE_TYPE (arg_node) == N_const) ||
	      (NODE_TYPE (arg_node) == N_enclosedexpr) ||
	      (NODE_TYPE (arg_node) == N_funcall) ||
	      (NODE_TYPE (arg_node) == N_monop) ||
	      (NODE_TYPE (arg_node) == N_var));
  return (res);
}

static bool
isSet_Const (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_bool) ||
	      (NODE_TYPE (arg_node) == N_float) ||
	      (NODE_TYPE (arg_node) == N_num));
  return (res);
}

static bool
isSet_RetType (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_key_bool) ||
	      (NODE_TYPE (arg_node) == N_key_float) ||
	      (NODE_TYPE (arg_node) == N_key_int) ||
	      (NODE_TYPE (arg_node) == N_key_void));
  return (res);
}

static bool
isSet_Statement (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_assign) ||
	      (NODE_TYPE (arg_node) == N_dowhilestat) ||
	      (NODE_TYPE (arg_node) == N_forstat) ||
	      (NODE_TYPE (arg_node) == N_funcall) ||
	      (NODE_TYPE (arg_node) == N_ifstat) ||
	      (NODE_TYPE (arg_node) == N_whilestat));
  return (res);
}

static bool
isSet_Type (node * arg_node)
{
  bool res = ((NODE_TYPE (arg_node) == N_key_bool) ||
	      (NODE_TYPE (arg_node) == N_key_float) ||
	      (NODE_TYPE (arg_node) == N_key_int));
  return (res);
}

void
isDummy ()
{
  isBlock (NULL);
  isCodeBlock (NULL);
  isExpr (NULL);
  isSet_Const (NULL);
  isSet_RetType (NULL);
  isSet_Statement (NULL);
  isSet_Type (NULL);
}

/** <!--******************************************************************-->
 *
 * @fn CHKassign
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Assign node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKassign (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKassign");

/*
 * Son check: ASSIGN_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ASSIGN_EXPR (arg_node), arg_node,
		   "mandatory son ASSIGN_EXPR is NULL");
      if (ASSIGN_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (ASSIGN_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ASSIGN_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (ASSIGN_EXPR (arg_node), arg_node,
		   "attribute ASSIGN_EXPR must be NULL");
    }

/*
 * Son check: ASSIGN_LET 
 */
  if ((FALSE) || (TRUE))
    {
      if (ASSIGN_LET (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (ASSIGN_LET (arg_node)) == N_varlet)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ASSIGN_LET hasnt the right type."
					 " It should be: " "N_varlet");
	    }
	}
    }
  else
    {
      CHKnotExist (ASSIGN_LET (arg_node), arg_node,
		   "attribute ASSIGN_LET must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ASSIGN_EXPR (arg_node) != NULL)
    {
      ASSIGN_EXPR (arg_node) = TRAVdo (ASSIGN_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (ASSIGN_LET (arg_node) != NULL)
    {
      ASSIGN_LET (arg_node) = TRAVdo (ASSIGN_LET (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKbinop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node BinOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKbinop (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKbinop");

/*
 * Son check: BINOP_LEFT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (BINOP_LEFT (arg_node), arg_node,
		   "mandatory son BINOP_LEFT is NULL");
      if (BINOP_LEFT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (BINOP_LEFT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BINOP_LEFT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (BINOP_LEFT (arg_node), arg_node,
		   "attribute BINOP_LEFT must be NULL");
    }

/*
 * Son check: BINOP_RIGHT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (BINOP_RIGHT (arg_node), arg_node,
		   "mandatory son BINOP_RIGHT is NULL");
      if (BINOP_RIGHT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (BINOP_RIGHT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "BINOP_RIGHT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (BINOP_RIGHT (arg_node), arg_node,
		   "attribute BINOP_RIGHT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (BINOP_LEFT (arg_node) != NULL)
    {
      BINOP_LEFT (arg_node) = TRAVdo (BINOP_LEFT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (BINOP_RIGHT (arg_node) != NULL)
    {
      BINOP_RIGHT (arg_node) = TRAVdo (BINOP_RIGHT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKbool
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Bool node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKbool (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKbool");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKcast
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Cast node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKcast (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKcast");

/*
 * Son check: CAST_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (CAST_EXPR (arg_node), arg_node,
		   "mandatory son CAST_EXPR is NULL");
      if (CAST_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (CAST_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "CAST_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (CAST_EXPR (arg_node), arg_node,
		   "attribute CAST_EXPR must be NULL");
    }

/*
 * Son check: CAST_L_BRACKET 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (CAST_L_BRACKET (arg_node), arg_node,
		   "mandatory son CAST_L_BRACKET is NULL");
      if (CAST_L_BRACKET (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (CAST_L_BRACKET (arg_node)) == N_l_bracket)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "CAST_L_BRACKET hasnt the right type."
					 " It should be: " "N_l_bracket");
	    }
	}
    }
  else
    {
      CHKnotExist (CAST_L_BRACKET (arg_node), arg_node,
		   "attribute CAST_L_BRACKET must be NULL");
    }

/*
 * Son check: CAST_R_BRACKET 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (CAST_R_BRACKET (arg_node), arg_node,
		   "mandatory son CAST_R_BRACKET is NULL");
      if (CAST_R_BRACKET (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (CAST_R_BRACKET (arg_node)) == N_r_bracket)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "CAST_R_BRACKET hasnt the right type."
					 " It should be: " "N_r_bracket");
	    }
	}
    }
  else
    {
      CHKnotExist (CAST_R_BRACKET (arg_node), arg_node,
		   "attribute CAST_R_BRACKET must be NULL");
    }

/*
 * Son check: CAST_TYPE 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (CAST_TYPE (arg_node), arg_node,
		   "mandatory son CAST_TYPE is NULL");
      if (CAST_TYPE (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (CAST_TYPE (arg_node)) == N_type)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "CAST_TYPE hasnt the right type."
					 " It should be: " "N_type");
	    }
	}
    }
  else
    {
      CHKnotExist (CAST_TYPE (arg_node), arg_node,
		   "attribute CAST_TYPE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (CAST_EXPR (arg_node) != NULL)
    {
      CAST_EXPR (arg_node) = TRAVdo (CAST_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (CAST_L_BRACKET (arg_node) != NULL)
    {
      CAST_L_BRACKET (arg_node) =
	TRAVdo (CAST_L_BRACKET (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (CAST_R_BRACKET (arg_node) != NULL)
    {
      CAST_R_BRACKET (arg_node) =
	TRAVdo (CAST_R_BRACKET (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (CAST_TYPE (arg_node) != NULL)
    {
      CAST_TYPE (arg_node) = TRAVdo (CAST_TYPE (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKconst
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Const node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKconst (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKconst");

/*
 * Son check: CONST_SET_CONST 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (CONST_SET_CONST (arg_node), arg_node,
		   "mandatory son CONST_SET_CONST is NULL");
      if (CONST_SET_CONST (arg_node) != NULL)
	{
	  if (!((FALSE) || (isSet_Const (CONST_SET_CONST (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "CONST_SET_CONST hasnt the right type."
					 " It should be: "
					 "Nodeset: Set_Const");
	    }
	}
    }
  else
    {
      CHKnotExist (CONST_SET_CONST (arg_node), arg_node,
		   "attribute CONST_SET_CONST must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (CONST_SET_CONST (arg_node) != NULL)
    {
      CONST_SET_CONST (arg_node) =
	TRAVdo (CONST_SET_CONST (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKdo
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Do node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKdo (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKdo");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKdowhilestat
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node DoWhileStat node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKdowhilestat (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKdowhilestat");

/*
 * Son check: DOWHILESTAT_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DOWHILESTAT_BLOCK (arg_node), arg_node,
		   "mandatory son DOWHILESTAT_BLOCK is NULL");
      if (DOWHILESTAT_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (isBlock (DOWHILESTAT_BLOCK (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DOWHILESTAT_BLOCK hasnt the right type."
					 " It should be: " "Nodeset: Block");
	    }
	}
    }
  else
    {
      CHKnotExist (DOWHILESTAT_BLOCK (arg_node), arg_node,
		   "attribute DOWHILESTAT_BLOCK must be NULL");
    }

/*
 * Son check: DOWHILESTAT_DO 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DOWHILESTAT_DO (arg_node), arg_node,
		   "mandatory son DOWHILESTAT_DO is NULL");
      if (DOWHILESTAT_DO (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (DOWHILESTAT_DO (arg_node)) == N_do)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DOWHILESTAT_DO hasnt the right type."
					 " It should be: " "N_do");
	    }
	}
    }
  else
    {
      CHKnotExist (DOWHILESTAT_DO (arg_node), arg_node,
		   "attribute DOWHILESTAT_DO must be NULL");
    }

/*
 * Son check: DOWHILESTAT_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DOWHILESTAT_EXPR (arg_node), arg_node,
		   "mandatory son DOWHILESTAT_EXPR is NULL");
      if (DOWHILESTAT_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (DOWHILESTAT_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DOWHILESTAT_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (DOWHILESTAT_EXPR (arg_node), arg_node,
		   "attribute DOWHILESTAT_EXPR must be NULL");
    }

/*
 * Son check: DOWHILESTAT_WHILE 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (DOWHILESTAT_WHILE (arg_node), arg_node,
		   "mandatory son DOWHILESTAT_WHILE is NULL");
      if (DOWHILESTAT_WHILE (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (DOWHILESTAT_WHILE (arg_node)) == N_while)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "DOWHILESTAT_WHILE hasnt the right type."
					 " It should be: " "N_while");
	    }
	}
    }
  else
    {
      CHKnotExist (DOWHILESTAT_WHILE (arg_node), arg_node,
		   "attribute DOWHILESTAT_WHILE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (DOWHILESTAT_BLOCK (arg_node) != NULL)
    {
      DOWHILESTAT_BLOCK (arg_node) =
	TRAVdo (DOWHILESTAT_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (DOWHILESTAT_DO (arg_node) != NULL)
    {
      DOWHILESTAT_DO (arg_node) =
	TRAVdo (DOWHILESTAT_DO (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (DOWHILESTAT_EXPR (arg_node) != NULL)
    {
      DOWHILESTAT_EXPR (arg_node) =
	TRAVdo (DOWHILESTAT_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (DOWHILESTAT_WHILE (arg_node) != NULL)
    {
      DOWHILESTAT_WHILE (arg_node) =
	TRAVdo (DOWHILESTAT_WHILE (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKelse
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Else node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKelse (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKelse");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKelseblock
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node ElseBlock node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKelseblock (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKelseblock");

/*
 * Son check: ELSEBLOCK_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ELSEBLOCK_BLOCK (arg_node), arg_node,
		   "mandatory son ELSEBLOCK_BLOCK is NULL");
      if (ELSEBLOCK_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (isBlock (ELSEBLOCK_BLOCK (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ELSEBLOCK_BLOCK hasnt the right type."
					 " It should be: " "Nodeset: Block");
	    }
	}
    }
  else
    {
      CHKnotExist (ELSEBLOCK_BLOCK (arg_node), arg_node,
		   "attribute ELSEBLOCK_BLOCK must be NULL");
    }

/*
 * Son check: ELSEBLOCK_ELSE 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ELSEBLOCK_ELSE (arg_node), arg_node,
		   "mandatory son ELSEBLOCK_ELSE is NULL");
      if (ELSEBLOCK_ELSE (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (ELSEBLOCK_ELSE (arg_node)) == N_else)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ELSEBLOCK_ELSE hasnt the right type."
					 " It should be: " "N_else");
	    }
	}
    }
  else
    {
      CHKnotExist (ELSEBLOCK_ELSE (arg_node), arg_node,
		   "attribute ELSEBLOCK_ELSE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ELSEBLOCK_BLOCK (arg_node) != NULL)
    {
      ELSEBLOCK_BLOCK (arg_node) =
	TRAVdo (ELSEBLOCK_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (ELSEBLOCK_ELSE (arg_node) != NULL)
    {
      ELSEBLOCK_ELSE (arg_node) =
	TRAVdo (ELSEBLOCK_ELSE (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKenclosedblock
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node EnclosedBlock node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKenclosedblock (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKenclosedblock");

/*
 * Son check: ENCLOSEDBLOCK_L_FL_BRACKET 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ENCLOSEDBLOCK_L_FL_BRACKET (arg_node), arg_node,
		   "mandatory son ENCLOSEDBLOCK_L_FL_BRACKET is NULL");
      if (ENCLOSEDBLOCK_L_FL_BRACKET (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (ENCLOSEDBLOCK_L_FL_BRACKET (arg_node)) ==
		   N_l_fl_bracket)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ENCLOSEDBLOCK_L_FL_BRACKET hasnt the right type."
					 " It should be: " "N_l_fl_bracket");
	    }
	}
    }
  else
    {
      CHKnotExist (ENCLOSEDBLOCK_L_FL_BRACKET (arg_node), arg_node,
		   "attribute ENCLOSEDBLOCK_L_FL_BRACKET must be NULL");
    }

/*
 * Son check: ENCLOSEDBLOCK_R_FL_BRACKET 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ENCLOSEDBLOCK_R_FL_BRACKET (arg_node), arg_node,
		   "mandatory son ENCLOSEDBLOCK_R_FL_BRACKET is NULL");
      if (ENCLOSEDBLOCK_R_FL_BRACKET (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (ENCLOSEDBLOCK_R_FL_BRACKET (arg_node)) ==
		   N_r_fl_bracket)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ENCLOSEDBLOCK_R_FL_BRACKET hasnt the right type."
					 " It should be: " "N_r_fl_bracket");
	    }
	}
    }
  else
    {
      CHKnotExist (ENCLOSEDBLOCK_R_FL_BRACKET (arg_node), arg_node,
		   "attribute ENCLOSEDBLOCK_R_FL_BRACKET must be NULL");
    }

/*
 * Son check: ENCLOSEDBLOCK_STATEMENTLIST 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ENCLOSEDBLOCK_STATEMENTLIST (arg_node), arg_node,
		   "mandatory son ENCLOSEDBLOCK_STATEMENTLIST is NULL");
      if (ENCLOSEDBLOCK_STATEMENTLIST (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (ENCLOSEDBLOCK_STATEMENTLIST (arg_node)) ==
		   N_statementlist)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ENCLOSEDBLOCK_STATEMENTLIST hasnt the right type."
					 " It should be: " "N_statementlist");
	    }
	}
    }
  else
    {
      CHKnotExist (ENCLOSEDBLOCK_STATEMENTLIST (arg_node), arg_node,
		   "attribute ENCLOSEDBLOCK_STATEMENTLIST must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ENCLOSEDBLOCK_L_FL_BRACKET (arg_node) != NULL)
    {
      ENCLOSEDBLOCK_L_FL_BRACKET (arg_node) =
	TRAVdo (ENCLOSEDBLOCK_L_FL_BRACKET (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (ENCLOSEDBLOCK_R_FL_BRACKET (arg_node) != NULL)
    {
      ENCLOSEDBLOCK_R_FL_BRACKET (arg_node) =
	TRAVdo (ENCLOSEDBLOCK_R_FL_BRACKET (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (ENCLOSEDBLOCK_STATEMENTLIST (arg_node) != NULL)
    {
      ENCLOSEDBLOCK_STATEMENTLIST (arg_node) =
	TRAVdo (ENCLOSEDBLOCK_STATEMENTLIST (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKenclosedexpr
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node EnclosedExpr node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKenclosedexpr (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKenclosedexpr");

/*
 * Son check: ENCLOSEDEXPR_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ENCLOSEDEXPR_EXPR (arg_node), arg_node,
		   "mandatory son ENCLOSEDEXPR_EXPR is NULL");
      if (ENCLOSEDEXPR_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (ENCLOSEDEXPR_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ENCLOSEDEXPR_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (ENCLOSEDEXPR_EXPR (arg_node), arg_node,
		   "attribute ENCLOSEDEXPR_EXPR must be NULL");
    }

/*
 * Son check: ENCLOSEDEXPR_L_BRACKET 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ENCLOSEDEXPR_L_BRACKET (arg_node), arg_node,
		   "mandatory son ENCLOSEDEXPR_L_BRACKET is NULL");
      if (ENCLOSEDEXPR_L_BRACKET (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (ENCLOSEDEXPR_L_BRACKET (arg_node)) ==
		   N_l_bracket)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ENCLOSEDEXPR_L_BRACKET hasnt the right type."
					 " It should be: " "N_l_bracket");
	    }
	}
    }
  else
    {
      CHKnotExist (ENCLOSEDEXPR_L_BRACKET (arg_node), arg_node,
		   "attribute ENCLOSEDEXPR_L_BRACKET must be NULL");
    }

/*
 * Son check: ENCLOSEDEXPR_R_BRACKET 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (ENCLOSEDEXPR_R_BRACKET (arg_node), arg_node,
		   "mandatory son ENCLOSEDEXPR_R_BRACKET is NULL");
      if (ENCLOSEDEXPR_R_BRACKET (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (ENCLOSEDEXPR_R_BRACKET (arg_node)) ==
		   N_r_bracket)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ENCLOSEDEXPR_R_BRACKET hasnt the right type."
					 " It should be: " "N_r_bracket");
	    }
	}
    }
  else
    {
      CHKnotExist (ENCLOSEDEXPR_R_BRACKET (arg_node), arg_node,
		   "attribute ENCLOSEDEXPR_R_BRACKET must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ENCLOSEDEXPR_EXPR (arg_node) != NULL)
    {
      ENCLOSEDEXPR_EXPR (arg_node) =
	TRAVdo (ENCLOSEDEXPR_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (ENCLOSEDEXPR_L_BRACKET (arg_node) != NULL)
    {
      ENCLOSEDEXPR_L_BRACKET (arg_node) =
	TRAVdo (ENCLOSEDEXPR_L_BRACKET (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (ENCLOSEDEXPR_R_BRACKET (arg_node) != NULL)
    {
      ENCLOSEDEXPR_R_BRACKET (arg_node) =
	TRAVdo (ENCLOSEDEXPR_R_BRACKET (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKequals
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Equals node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKequals (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKequals");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKerror
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Error node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKerror (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKerror");

/*
 * Son check: ERROR_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (ERROR_NEXT (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (ERROR_NEXT (arg_node)) == N_error)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "ERROR_NEXT hasnt the right type."
					 " It should be: " "N_error");
	    }
	}
    }
  else
    {
      CHKnotExist (ERROR_NEXT (arg_node), arg_node,
		   "attribute ERROR_NEXT must be NULL");
    }

/*
 * Attribute check: ERROR_MESSAGE
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (ERROR_MESSAGE (arg_node), arg_node,
			 "mandatory attribute ERROR_MESSAGE is NULL");
    }
  else
    {
      CHKnotExist (ERROR_MESSAGE (arg_node), arg_node,
		   "attribute ERROR_MESSAGE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (ERROR_NEXT (arg_node) != NULL)
    {
      ERROR_NEXT (arg_node) = TRAVdo (ERROR_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKexport
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Export node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKexport (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKexport");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKexprlist
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node ExprList node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKexprlist (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKexprlist");

/*
 * Son check: EXPRLIST_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (EXPRLIST_EXPR (arg_node), arg_node,
		   "mandatory son EXPRLIST_EXPR is NULL");
      if (EXPRLIST_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (EXPRLIST_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "EXPRLIST_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (EXPRLIST_EXPR (arg_node), arg_node,
		   "attribute EXPRLIST_EXPR must be NULL");
    }

/*
 * Son check: EXPRLIST_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (EXPRLIST_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (EXPRLIST_NEXT (arg_node)) == N_exprlist)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "EXPRLIST_NEXT hasnt the right type."
					 " It should be: " "N_exprlist");
	    }
	}
    }
  else
    {
      CHKnotExist (EXPRLIST_NEXT (arg_node), arg_node,
		   "attribute EXPRLIST_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (EXPRLIST_EXPR (arg_node) != NULL)
    {
      EXPRLIST_EXPR (arg_node) = TRAVdo (EXPRLIST_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (EXPRLIST_NEXT (arg_node) != NULL)
    {
      EXPRLIST_NEXT (arg_node) = TRAVdo (EXPRLIST_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKextern
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Extern node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKextern (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKextern");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfloat
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Float node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfloat (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfloat");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfor
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node For node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfor (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfor");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfordec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node ForDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfordec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfordec");

/*
 * Son check: FORDEC_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FORDEC_EXPR (arg_node), arg_node,
		   "mandatory son FORDEC_EXPR is NULL");
      if (FORDEC_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (FORDEC_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FORDEC_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (FORDEC_EXPR (arg_node), arg_node,
		   "attribute FORDEC_EXPR must be NULL");
    }

/*
 * Son check: FORDEC_FORVARINIT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FORDEC_FORVARINIT (arg_node), arg_node,
		   "mandatory son FORDEC_FORVARINIT is NULL");
      if (FORDEC_FORVARINIT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FORDEC_FORVARINIT (arg_node)) == N_forvarinit)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FORDEC_FORVARINIT hasnt the right type."
					 " It should be: " "N_forvarinit");
	    }
	}
    }
  else
    {
      CHKnotExist (FORDEC_FORVARINIT (arg_node), arg_node,
		   "attribute FORDEC_FORVARINIT must be NULL");
    }

/*
 * Son check: FORDEC_TYPE 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FORDEC_TYPE (arg_node), arg_node,
		   "mandatory son FORDEC_TYPE is NULL");
      if (FORDEC_TYPE (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FORDEC_TYPE (arg_node)) == N_type)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FORDEC_TYPE hasnt the right type."
					 " It should be: " "N_type");
	    }
	}
    }
  else
    {
      CHKnotExist (FORDEC_TYPE (arg_node), arg_node,
		   "attribute FORDEC_TYPE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FORDEC_EXPR (arg_node) != NULL)
    {
      FORDEC_EXPR (arg_node) = TRAVdo (FORDEC_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FORDEC_FORVARINIT (arg_node) != NULL)
    {
      FORDEC_FORVARINIT (arg_node) =
	TRAVdo (FORDEC_FORVARINIT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FORDEC_TYPE (arg_node) != NULL)
    {
      FORDEC_TYPE (arg_node) = TRAVdo (FORDEC_TYPE (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKforstat
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node ForStat node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKforstat (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKforstat");

/*
 * Son check: FORSTAT_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FORSTAT_BLOCK (arg_node), arg_node,
		   "mandatory son FORSTAT_BLOCK is NULL");
      if (FORSTAT_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (isBlock (FORSTAT_BLOCK (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FORSTAT_BLOCK hasnt the right type."
					 " It should be: " "Nodeset: Block");
	    }
	}
    }
  else
    {
      CHKnotExist (FORSTAT_BLOCK (arg_node), arg_node,
		   "attribute FORSTAT_BLOCK must be NULL");
    }

/*
 * Son check: FORSTAT_FOR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FORSTAT_FOR (arg_node), arg_node,
		   "mandatory son FORSTAT_FOR is NULL");
      if (FORSTAT_FOR (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FORSTAT_FOR (arg_node)) == N_for)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FORSTAT_FOR hasnt the right type."
					 " It should be: " "N_for");
	    }
	}
    }
  else
    {
      CHKnotExist (FORSTAT_FOR (arg_node), arg_node,
		   "attribute FORSTAT_FOR must be NULL");
    }

/*
 * Son check: FORSTAT_FORDEC 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FORSTAT_FORDEC (arg_node), arg_node,
		   "mandatory son FORSTAT_FORDEC is NULL");
      if (FORSTAT_FORDEC (arg_node) != NULL)
	{
	  if (!((FALSE) || (isForDec (FORSTAT_FORDEC (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FORSTAT_FORDEC hasnt the right type."
					 " It should be: " "Nodeset: ForDec");
	    }
	}
    }
  else
    {
      CHKnotExist (FORSTAT_FORDEC (arg_node), arg_node,
		   "attribute FORSTAT_FORDEC must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FORSTAT_BLOCK (arg_node) != NULL)
    {
      FORSTAT_BLOCK (arg_node) = TRAVdo (FORSTAT_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FORSTAT_FOR (arg_node) != NULL)
    {
      FORSTAT_FOR (arg_node) = TRAVdo (FORSTAT_FOR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FORSTAT_FORDEC (arg_node) != NULL)
    {
      FORSTAT_FORDEC (arg_node) =
	TRAVdo (FORSTAT_FORDEC (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKforvarinit
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node ForVarInit node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKforvarinit (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKforvarinit");

/*
 * Son check: FORVARINIT_EQUALS 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FORVARINIT_EQUALS (arg_node), arg_node,
		   "mandatory son FORVARINIT_EQUALS is NULL");
      if (FORVARINIT_EQUALS (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FORVARINIT_EQUALS (arg_node)) == N_equals)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FORVARINIT_EQUALS hasnt the right type."
					 " It should be: " "N_equals");
	    }
	}
    }
  else
    {
      CHKnotExist (FORVARINIT_EQUALS (arg_node), arg_node,
		   "attribute FORVARINIT_EQUALS must be NULL");
    }

/*
 * Son check: FORVARINIT_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FORVARINIT_EXPR (arg_node), arg_node,
		   "mandatory son FORVARINIT_EXPR is NULL");
      if (FORVARINIT_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (FORVARINIT_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FORVARINIT_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (FORVARINIT_EXPR (arg_node), arg_node,
		   "attribute FORVARINIT_EXPR must be NULL");
    }

/*
 * Son check: FORVARINIT_VARLET 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FORVARINIT_VARLET (arg_node), arg_node,
		   "mandatory son FORVARINIT_VARLET is NULL");
      if (FORVARINIT_VARLET (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FORVARINIT_VARLET (arg_node)) == N_varlet)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FORVARINIT_VARLET hasnt the right type."
					 " It should be: " "N_varlet");
	    }
	}
    }
  else
    {
      CHKnotExist (FORVARINIT_VARLET (arg_node), arg_node,
		   "attribute FORVARINIT_VARLET must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FORVARINIT_EQUALS (arg_node) != NULL)
    {
      FORVARINIT_EQUALS (arg_node) =
	TRAVdo (FORVARINIT_EQUALS (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FORVARINIT_EXPR (arg_node) != NULL)
    {
      FORVARINIT_EXPR (arg_node) =
	TRAVdo (FORVARINIT_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FORVARINIT_VARLET (arg_node) != NULL)
    {
      FORVARINIT_VARLET (arg_node) =
	TRAVdo (FORVARINIT_VARLET (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfunbody
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunBody node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfunbody (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfunbody");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfuncall
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunCall node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfuncall (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfuncall");

/*
 * Son check: FUNCALL_EXPRLIST 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNCALL_EXPRLIST (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNCALL_EXPRLIST (arg_node)) == N_exprlist)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNCALL_EXPRLIST hasnt the right type."
					 " It should be: " "N_exprlist");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNCALL_EXPRLIST (arg_node), arg_node,
		   "attribute FUNCALL_EXPRLIST must be NULL");
    }

/*
 * Son check: FUNCALL_VAR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNCALL_VAR (arg_node), arg_node,
		   "mandatory son FUNCALL_VAR is NULL");
      if (FUNCALL_VAR (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FUNCALL_VAR (arg_node)) == N_var)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNCALL_VAR hasnt the right type."
					 " It should be: " "N_var");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNCALL_VAR (arg_node), arg_node,
		   "attribute FUNCALL_VAR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNCALL_EXPRLIST (arg_node) != NULL)
    {
      FUNCALL_EXPRLIST (arg_node) =
	TRAVdo (FUNCALL_EXPRLIST (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNCALL_VAR (arg_node) != NULL)
    {
      FUNCALL_VAR (arg_node) = TRAVdo (FUNCALL_VAR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfundec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfundec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfundec");

/*
 * Son check: FUNDEC_EXTERN 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNDEC_EXTERN (arg_node), arg_node,
		   "mandatory son FUNDEC_EXTERN is NULL");
      if (FUNDEC_EXTERN (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (NODE_TYPE (FUNDEC_EXTERN (arg_node)) == N_extern)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEC_EXTERN hasnt the right type."
					 " It should be: " "N_extern");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEC_EXTERN (arg_node), arg_node,
		   "attribute FUNDEC_EXTERN must be NULL");
    }

/*
 * Son check: FUNDEC_FUNHEADER 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNDEC_FUNHEADER (arg_node), arg_node,
		   "mandatory son FUNDEC_FUNHEADER is NULL");
      if (FUNDEC_FUNHEADER (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEC_FUNHEADER (arg_node)) == N_funheader)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEC_FUNHEADER hasnt the right type."
					 " It should be: " "N_funheader");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEC_FUNHEADER (arg_node), arg_node,
		   "attribute FUNDEC_FUNHEADER must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEC_EXTERN (arg_node) != NULL)
    {
      FUNDEC_EXTERN (arg_node) = TRAVdo (FUNDEC_EXTERN (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEC_FUNHEADER (arg_node) != NULL)
    {
      FUNDEC_FUNHEADER (arg_node) =
	TRAVdo (FUNDEC_FUNHEADER (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfundef
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunDef node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfundef (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfundef");

/*
 * Son check: FUNDEF_EXPORT 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNDEF_EXPORT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (NODE_TYPE (FUNDEF_EXPORT (arg_node)) == N_export)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEF_EXPORT hasnt the right type."
					 " It should be: " "N_export");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEF_EXPORT (arg_node), arg_node,
		   "attribute FUNDEF_EXPORT must be NULL");
    }

/*
 * Son check: FUNDEF_FUNBODY 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNDEF_FUNBODY (arg_node), arg_node,
		   "mandatory son FUNDEF_FUNBODY is NULL");
      if (FUNDEF_FUNBODY (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEF_FUNBODY (arg_node)) == N_funbody)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEF_FUNBODY hasnt the right type."
					 " It should be: " "N_funbody");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEF_FUNBODY (arg_node), arg_node,
		   "attribute FUNDEF_FUNBODY must be NULL");
    }

/*
 * Son check: FUNDEF_FUNHEADER 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNDEF_FUNHEADER (arg_node), arg_node,
		   "mandatory son FUNDEF_FUNHEADER is NULL");
      if (FUNDEF_FUNHEADER (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNDEF_FUNHEADER (arg_node)) == N_funheader)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNDEF_FUNHEADER hasnt the right type."
					 " It should be: " "N_funheader");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNDEF_FUNHEADER (arg_node), arg_node,
		   "attribute FUNDEF_FUNHEADER must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEF_EXPORT (arg_node) != NULL)
    {
      FUNDEF_EXPORT (arg_node) = TRAVdo (FUNDEF_EXPORT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEF_FUNBODY (arg_node) != NULL)
    {
      FUNDEF_FUNBODY (arg_node) =
	TRAVdo (FUNDEF_FUNBODY (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNDEF_FUNHEADER (arg_node) != NULL)
    {
      FUNDEF_FUNHEADER (arg_node) =
	TRAVdo (FUNDEF_FUNHEADER (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKfunheader
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node FunHeader node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKfunheader (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKfunheader");

/*
 * Son check: FUNHEADER_PARAMLIST 
 */
  if ((FALSE) || (TRUE))
    {
      if (FUNHEADER_PARAMLIST (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNHEADER_PARAMLIST (arg_node)) ==
		   N_paramlist)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNHEADER_PARAMLIST hasnt the right type."
					 " It should be: " "N_paramlist");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNHEADER_PARAMLIST (arg_node), arg_node,
		   "attribute FUNHEADER_PARAMLIST must be NULL");
    }

/*
 * Son check: FUNHEADER_RETTYPE 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNHEADER_RETTYPE (arg_node), arg_node,
		   "mandatory son FUNHEADER_RETTYPE is NULL");
      if (FUNHEADER_RETTYPE (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (FUNHEADER_RETTYPE (arg_node)) == N_rettype)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNHEADER_RETTYPE hasnt the right type."
					 " It should be: " "N_rettype");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNHEADER_RETTYPE (arg_node), arg_node,
		   "attribute FUNHEADER_RETTYPE must be NULL");
    }

/*
 * Son check: FUNHEADER_VAR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (FUNHEADER_VAR (arg_node), arg_node,
		   "mandatory son FUNHEADER_VAR is NULL");
      if (FUNHEADER_VAR (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (FUNHEADER_VAR (arg_node)) == N_var)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "FUNHEADER_VAR hasnt the right type."
					 " It should be: " "N_var");
	    }
	}
    }
  else
    {
      CHKnotExist (FUNHEADER_VAR (arg_node), arg_node,
		   "attribute FUNHEADER_VAR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (FUNHEADER_PARAMLIST (arg_node) != NULL)
    {
      FUNHEADER_PARAMLIST (arg_node) =
	TRAVdo (FUNHEADER_PARAMLIST (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNHEADER_RETTYPE (arg_node) != NULL)
    {
      FUNHEADER_RETTYPE (arg_node) =
	TRAVdo (FUNHEADER_RETTYPE (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (FUNHEADER_VAR (arg_node) != NULL)
    {
      FUNHEADER_VAR (arg_node) = TRAVdo (FUNHEADER_VAR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKglobaldec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node GlobalDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKglobaldec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKglobaldec");

/*
 * Son check: GLOBALDEC_EXTERN 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (GLOBALDEC_EXTERN (arg_node), arg_node,
		   "mandatory son GLOBALDEC_EXTERN is NULL");
      if (GLOBALDEC_EXTERN (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (GLOBALDEC_EXTERN (arg_node)) == N_extern)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEC_EXTERN hasnt the right type."
					 " It should be: " "N_extern");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEC_EXTERN (arg_node), arg_node,
		   "attribute GLOBALDEC_EXTERN must be NULL");
    }

/*
 * Son check: GLOBALDEC_TYPE 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (GLOBALDEC_TYPE (arg_node), arg_node,
		   "mandatory son GLOBALDEC_TYPE is NULL");
      if (GLOBALDEC_TYPE (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (GLOBALDEC_TYPE (arg_node)) == N_type)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEC_TYPE hasnt the right type."
					 " It should be: " "N_type");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEC_TYPE (arg_node), arg_node,
		   "attribute GLOBALDEC_TYPE must be NULL");
    }

/*
 * Son check: GLOBALDEC_VAR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (GLOBALDEC_VAR (arg_node), arg_node,
		   "mandatory son GLOBALDEC_VAR is NULL");
      if (GLOBALDEC_VAR (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (GLOBALDEC_VAR (arg_node)) == N_var)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEC_VAR hasnt the right type."
					 " It should be: " "N_var");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEC_VAR (arg_node), arg_node,
		   "attribute GLOBALDEC_VAR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEC_EXTERN (arg_node) != NULL)
    {
      GLOBALDEC_EXTERN (arg_node) =
	TRAVdo (GLOBALDEC_EXTERN (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEC_TYPE (arg_node) != NULL)
    {
      GLOBALDEC_TYPE (arg_node) =
	TRAVdo (GLOBALDEC_TYPE (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEC_VAR (arg_node) != NULL)
    {
      GLOBALDEC_VAR (arg_node) = TRAVdo (GLOBALDEC_VAR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKglobaldef
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node GlobalDef node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKglobaldef (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKglobaldef");

/*
 * Son check: GLOBALDEF_EXPORT 
 */
  if ((FALSE) || (TRUE))
    {
      if (GLOBALDEF_EXPORT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (GLOBALDEF_EXPORT (arg_node)) == N_export)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEF_EXPORT hasnt the right type."
					 " It should be: " "N_export");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEF_EXPORT (arg_node), arg_node,
		   "attribute GLOBALDEF_EXPORT must be NULL");
    }

/*
 * Son check: GLOBALDEF_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      if (GLOBALDEF_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (GLOBALDEF_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEF_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEF_EXPR (arg_node), arg_node,
		   "attribute GLOBALDEF_EXPR must be NULL");
    }

/*
 * Son check: GLOBALDEF_TYPE 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (GLOBALDEF_TYPE (arg_node), arg_node,
		   "mandatory son GLOBALDEF_TYPE is NULL");
      if (GLOBALDEF_TYPE (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (GLOBALDEF_TYPE (arg_node)) == N_type)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEF_TYPE hasnt the right type."
					 " It should be: " "N_type");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEF_TYPE (arg_node), arg_node,
		   "attribute GLOBALDEF_TYPE must be NULL");
    }

/*
 * Son check: GLOBALDEF_VAR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (GLOBALDEF_VAR (arg_node), arg_node,
		   "mandatory son GLOBALDEF_VAR is NULL");
      if (GLOBALDEF_VAR (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (GLOBALDEF_VAR (arg_node)) == N_var)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "GLOBALDEF_VAR hasnt the right type."
					 " It should be: " "N_var");
	    }
	}
    }
  else
    {
      CHKnotExist (GLOBALDEF_VAR (arg_node), arg_node,
		   "attribute GLOBALDEF_VAR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEF_EXPORT (arg_node) != NULL)
    {
      GLOBALDEF_EXPORT (arg_node) =
	TRAVdo (GLOBALDEF_EXPORT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEF_EXPR (arg_node) != NULL)
    {
      GLOBALDEF_EXPR (arg_node) =
	TRAVdo (GLOBALDEF_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEF_TYPE (arg_node) != NULL)
    {
      GLOBALDEF_TYPE (arg_node) =
	TRAVdo (GLOBALDEF_TYPE (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (GLOBALDEF_VAR (arg_node) != NULL)
    {
      GLOBALDEF_VAR (arg_node) = TRAVdo (GLOBALDEF_VAR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKifkeyword
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node IfKeyword node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKifkeyword (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKifkeyword");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKifstat
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node IfStat node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKifstat (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKifstat");

/*
 * Son check: IFSTAT_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (IFSTAT_BLOCK (arg_node), arg_node,
		   "mandatory son IFSTAT_BLOCK is NULL");
      if (IFSTAT_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (isBlock (IFSTAT_BLOCK (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IFSTAT_BLOCK hasnt the right type."
					 " It should be: " "Nodeset: Block");
	    }
	}
    }
  else
    {
      CHKnotExist (IFSTAT_BLOCK (arg_node), arg_node,
		   "attribute IFSTAT_BLOCK must be NULL");
    }

/*
 * Son check: IFSTAT_ELSEBLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      if (IFSTAT_ELSEBLOCK (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (IFSTAT_ELSEBLOCK (arg_node)) == N_elseblock)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IFSTAT_ELSEBLOCK hasnt the right type."
					 " It should be: " "N_elseblock");
	    }
	}
    }
  else
    {
      CHKnotExist (IFSTAT_ELSEBLOCK (arg_node), arg_node,
		   "attribute IFSTAT_ELSEBLOCK must be NULL");
    }

/*
 * Son check: IFSTAT_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (IFSTAT_EXPR (arg_node), arg_node,
		   "mandatory son IFSTAT_EXPR is NULL");
      if (IFSTAT_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (IFSTAT_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IFSTAT_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (IFSTAT_EXPR (arg_node), arg_node,
		   "attribute IFSTAT_EXPR must be NULL");
    }

/*
 * Son check: IFSTAT_IF 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (IFSTAT_IF (arg_node), arg_node,
		   "mandatory son IFSTAT_IF is NULL");
      if (IFSTAT_IF (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (IFSTAT_IF (arg_node)) == N_ifkeyword)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IFSTAT_IF hasnt the right type."
					 " It should be: " "N_ifkeyword");
	    }
	}
    }
  else
    {
      CHKnotExist (IFSTAT_IF (arg_node), arg_node,
		   "attribute IFSTAT_IF must be NULL");
    }

/*
 * Son check: IFSTAT_L_BRACKET 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (IFSTAT_L_BRACKET (arg_node), arg_node,
		   "mandatory son IFSTAT_L_BRACKET is NULL");
      if (IFSTAT_L_BRACKET (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (IFSTAT_L_BRACKET (arg_node)) == N_l_bracket)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IFSTAT_L_BRACKET hasnt the right type."
					 " It should be: " "N_l_bracket");
	    }
	}
    }
  else
    {
      CHKnotExist (IFSTAT_L_BRACKET (arg_node), arg_node,
		   "attribute IFSTAT_L_BRACKET must be NULL");
    }

/*
 * Son check: IFSTAT_R_BRACKET 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (IFSTAT_R_BRACKET (arg_node), arg_node,
		   "mandatory son IFSTAT_R_BRACKET is NULL");
      if (IFSTAT_R_BRACKET (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (IFSTAT_R_BRACKET (arg_node)) == N_r_bracket)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "IFSTAT_R_BRACKET hasnt the right type."
					 " It should be: " "N_r_bracket");
	    }
	}
    }
  else
    {
      CHKnotExist (IFSTAT_R_BRACKET (arg_node), arg_node,
		   "attribute IFSTAT_R_BRACKET must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (IFSTAT_BLOCK (arg_node) != NULL)
    {
      IFSTAT_BLOCK (arg_node) = TRAVdo (IFSTAT_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (IFSTAT_ELSEBLOCK (arg_node) != NULL)
    {
      IFSTAT_ELSEBLOCK (arg_node) =
	TRAVdo (IFSTAT_ELSEBLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (IFSTAT_EXPR (arg_node) != NULL)
    {
      IFSTAT_EXPR (arg_node) = TRAVdo (IFSTAT_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (IFSTAT_IF (arg_node) != NULL)
    {
      IFSTAT_IF (arg_node) = TRAVdo (IFSTAT_IF (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (IFSTAT_L_BRACKET (arg_node) != NULL)
    {
      IFSTAT_L_BRACKET (arg_node) =
	TRAVdo (IFSTAT_L_BRACKET (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (IFSTAT_R_BRACKET (arg_node) != NULL)
    {
      IFSTAT_R_BRACKET (arg_node) =
	TRAVdo (IFSTAT_R_BRACKET (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKkey_bool
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Key_Bool node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKkey_bool (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKkey_bool");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKkey_float
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Key_Float node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKkey_float (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKkey_float");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKkey_int
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Key_Int node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKkey_int (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKkey_int");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKkey_void
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Key_Void node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKkey_void (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKkey_void");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKl_bracket
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node L_Bracket node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKl_bracket (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKl_bracket");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKl_fl_bracket
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node L_FL_Bracket node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKl_fl_bracket (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKl_fl_bracket");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKmonop
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node MonOp node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKmonop (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKmonop");

/*
 * Son check: MONOP_RIGHT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (MONOP_RIGHT (arg_node), arg_node,
		   "mandatory son MONOP_RIGHT is NULL");
      if (MONOP_RIGHT (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (MONOP_RIGHT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "MONOP_RIGHT hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (MONOP_RIGHT (arg_node), arg_node,
		   "attribute MONOP_RIGHT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (MONOP_RIGHT (arg_node) != NULL)
    {
      MONOP_RIGHT (arg_node) = TRAVdo (MONOP_RIGHT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKnum
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Num node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKnum (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKnum");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKparam
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Param node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKparam (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKparam");

/*
 * Son check: PARAM_TYPE 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (PARAM_TYPE (arg_node), arg_node,
		   "mandatory son PARAM_TYPE is NULL");
      if (PARAM_TYPE (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (PARAM_TYPE (arg_node)) == N_type)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PARAM_TYPE hasnt the right type."
					 " It should be: " "N_type");
	    }
	}
    }
  else
    {
      CHKnotExist (PARAM_TYPE (arg_node), arg_node,
		   "attribute PARAM_TYPE must be NULL");
    }

/*
 * Son check: PARAM_VAR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (PARAM_VAR (arg_node), arg_node,
		   "mandatory son PARAM_VAR is NULL");
      if (PARAM_VAR (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (PARAM_VAR (arg_node)) == N_var)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PARAM_VAR hasnt the right type."
					 " It should be: " "N_var");
	    }
	}
    }
  else
    {
      CHKnotExist (PARAM_VAR (arg_node), arg_node,
		   "attribute PARAM_VAR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (PARAM_TYPE (arg_node) != NULL)
    {
      PARAM_TYPE (arg_node) = TRAVdo (PARAM_TYPE (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (PARAM_VAR (arg_node) != NULL)
    {
      PARAM_VAR (arg_node) = TRAVdo (PARAM_VAR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKparamlist
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node ParamList node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKparamlist (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKparamlist");

/*
 * Son check: PARAMLIST_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (PARAMLIST_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (PARAMLIST_NEXT (arg_node)) == N_paramlist)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PARAMLIST_NEXT hasnt the right type."
					 " It should be: " "N_paramlist");
	    }
	}
    }
  else
    {
      CHKnotExist (PARAMLIST_NEXT (arg_node), arg_node,
		   "attribute PARAMLIST_NEXT must be NULL");
    }

/*
 * Son check: PARAMLIST_PARAM 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (PARAMLIST_PARAM (arg_node), arg_node,
		   "mandatory son PARAMLIST_PARAM is NULL");
      if (PARAMLIST_PARAM (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (PARAMLIST_PARAM (arg_node)) == N_param)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PARAMLIST_PARAM hasnt the right type."
					 " It should be: " "N_param");
	    }
	}
    }
  else
    {
      CHKnotExist (PARAMLIST_PARAM (arg_node), arg_node,
		   "attribute PARAMLIST_PARAM must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (PARAMLIST_NEXT (arg_node) != NULL)
    {
      PARAMLIST_NEXT (arg_node) =
	TRAVdo (PARAMLIST_NEXT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (PARAMLIST_PARAM (arg_node) != NULL)
    {
      PARAMLIST_PARAM (arg_node) =
	TRAVdo (PARAMLIST_PARAM (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKprogram
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Program node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKprogram (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKprogram");

/*
 * Son check: PROGRAM_CODEBLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (PROGRAM_CODEBLOCK (arg_node), arg_node,
		   "mandatory son PROGRAM_CODEBLOCK is NULL");
      if (PROGRAM_CODEBLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (isCodeBlock (PROGRAM_CODEBLOCK (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PROGRAM_CODEBLOCK hasnt the right type."
					 " It should be: "
					 "Nodeset: CodeBlock");
	    }
	}
    }
  else
    {
      CHKnotExist (PROGRAM_CODEBLOCK (arg_node), arg_node,
		   "attribute PROGRAM_CODEBLOCK must be NULL");
    }

/*
 * Son check: PROGRAM_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (PROGRAM_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (NODE_TYPE (PROGRAM_NEXT (arg_node)) == N_program)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "PROGRAM_NEXT hasnt the right type."
					 " It should be: " "N_program");
	    }
	}
    }
  else
    {
      CHKnotExist (PROGRAM_NEXT (arg_node), arg_node,
		   "attribute PROGRAM_NEXT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (PROGRAM_CODEBLOCK (arg_node) != NULL)
    {
      PROGRAM_CODEBLOCK (arg_node) =
	TRAVdo (PROGRAM_CODEBLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (PROGRAM_NEXT (arg_node) != NULL)
    {
      PROGRAM_NEXT (arg_node) = TRAVdo (PROGRAM_NEXT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKr_bracket
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node R_Bracket node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKr_bracket (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKr_bracket");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKr_fl_bracket
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node R_FL_Bracket node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKr_fl_bracket (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKr_fl_bracket");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKrettype
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node RetType node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKrettype (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKrettype");

/*
 * Son check: RETTYPE_SET_RETTYPE 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (RETTYPE_SET_RETTYPE (arg_node), arg_node,
		   "mandatory son RETTYPE_SET_RETTYPE is NULL");
      if (RETTYPE_SET_RETTYPE (arg_node) != NULL)
	{
	  if (!((FALSE) || (isSet_RetType (RETTYPE_SET_RETTYPE (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "RETTYPE_SET_RETTYPE hasnt the right type."
					 " It should be: "
					 "Nodeset: Set_RetType");
	    }
	}
    }
  else
    {
      CHKnotExist (RETTYPE_SET_RETTYPE (arg_node), arg_node,
		   "attribute RETTYPE_SET_RETTYPE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (RETTYPE_SET_RETTYPE (arg_node) != NULL)
    {
      RETTYPE_SET_RETTYPE (arg_node) =
	TRAVdo (RETTYPE_SET_RETTYPE (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKreturn
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Return node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKreturn (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKreturn");

/*
 * Son check: RETURN_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (RETURN_EXPR (arg_node), arg_node,
		   "mandatory son RETURN_EXPR is NULL");
      if (RETURN_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (RETURN_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "RETURN_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (RETURN_EXPR (arg_node), arg_node,
		   "attribute RETURN_EXPR must be NULL");
    }

/*
 * Son check: RETURN_RETURNKEYWORD 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (RETURN_RETURNKEYWORD (arg_node), arg_node,
		   "mandatory son RETURN_RETURNKEYWORD is NULL");
      if (RETURN_RETURNKEYWORD (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (RETURN_RETURNKEYWORD (arg_node)) ==
		   N_returnkeyword)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "RETURN_RETURNKEYWORD hasnt the right type."
					 " It should be: " "N_returnkeyword");
	    }
	}
    }
  else
    {
      CHKnotExist (RETURN_RETURNKEYWORD (arg_node), arg_node,
		   "attribute RETURN_RETURNKEYWORD must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (RETURN_EXPR (arg_node) != NULL)
    {
      RETURN_EXPR (arg_node) = TRAVdo (RETURN_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (RETURN_RETURNKEYWORD (arg_node) != NULL)
    {
      RETURN_RETURNKEYWORD (arg_node) =
	TRAVdo (RETURN_RETURNKEYWORD (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKreturnkeyword
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node ReturnKeyword node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKreturnkeyword (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKreturnkeyword");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKstatement
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Statement node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKstatement (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKstatement");

/*
 * Son check: STATEMENT_SET_STATEMENT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (STATEMENT_SET_STATEMENT (arg_node), arg_node,
		   "mandatory son STATEMENT_SET_STATEMENT is NULL");
      if (STATEMENT_SET_STATEMENT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (isSet_Statement (STATEMENT_SET_STATEMENT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "STATEMENT_SET_STATEMENT hasnt the right type."
					 " It should be: "
					 "Nodeset: Set_Statement");
	    }
	}
    }
  else
    {
      CHKnotExist (STATEMENT_SET_STATEMENT (arg_node), arg_node,
		   "attribute STATEMENT_SET_STATEMENT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (STATEMENT_SET_STATEMENT (arg_node) != NULL)
    {
      STATEMENT_SET_STATEMENT (arg_node) =
	TRAVdo (STATEMENT_SET_STATEMENT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKstatementlist
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node StatementList node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKstatementlist (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKstatementlist");

/*
 * Son check: STATEMENTLIST_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (STATEMENTLIST_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (STATEMENTLIST_NEXT (arg_node)) ==
		   N_statementlist)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "STATEMENTLIST_NEXT hasnt the right type."
					 " It should be: " "N_statementlist");
	    }
	}
    }
  else
    {
      CHKnotExist (STATEMENTLIST_NEXT (arg_node), arg_node,
		   "attribute STATEMENTLIST_NEXT must be NULL");
    }

/*
 * Son check: STATEMENTLIST_STATEMENT 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (STATEMENTLIST_STATEMENT (arg_node), arg_node,
		   "mandatory son STATEMENTLIST_STATEMENT is NULL");
      if (STATEMENTLIST_STATEMENT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE) || (isStatement (STATEMENTLIST_STATEMENT (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "STATEMENTLIST_STATEMENT hasnt the right type."
					 " It should be: "
					 "Nodeset: Statement");
	    }
	}
    }
  else
    {
      CHKnotExist (STATEMENTLIST_STATEMENT (arg_node), arg_node,
		   "attribute STATEMENTLIST_STATEMENT must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (STATEMENTLIST_NEXT (arg_node) != NULL)
    {
      STATEMENTLIST_NEXT (arg_node) =
	TRAVdo (STATEMENTLIST_NEXT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (STATEMENTLIST_STATEMENT (arg_node) != NULL)
    {
      STATEMENTLIST_STATEMENT (arg_node) =
	TRAVdo (STATEMENTLIST_STATEMENT (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKtype
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Type node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKtype (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKtype");

/*
 * Son check: TYPE_SET_TYPE 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (TYPE_SET_TYPE (arg_node), arg_node,
		   "mandatory son TYPE_SET_TYPE is NULL");
      if (TYPE_SET_TYPE (arg_node) != NULL)
	{
	  if (!((FALSE) || (isSet_Type (TYPE_SET_TYPE (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "TYPE_SET_TYPE hasnt the right type."
					 " It should be: "
					 "Nodeset: Set_Type");
	    }
	}
    }
  else
    {
      CHKnotExist (TYPE_SET_TYPE (arg_node), arg_node,
		   "attribute TYPE_SET_TYPE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (TYPE_SET_TYPE (arg_node) != NULL)
    {
      TYPE_SET_TYPE (arg_node) = TRAVdo (TYPE_SET_TYPE (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvar
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node Var node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvar (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvar");

/*
 * Attribute check: VAR_DECL
 */
  if ((FALSE) || (TRUE))
    {
    }
  else
    {
      CHKnotExist (VAR_DECL (arg_node), arg_node,
		   "attribute VAR_DECL must be NULL");
    }

/*
 * Attribute check: VAR_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (VAR_NAME (arg_node), arg_node,
			 "mandatory attribute VAR_NAME is NULL");
    }
  else
    {
      CHKnotExist (VAR_NAME (arg_node), arg_node,
		   "attribute VAR_NAME must be NULL");
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvardec
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node VarDec node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvardec (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvardec");

/*
 * Son check: VARDEC_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      if (VARDEC_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (VARDEC_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDEC_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDEC_EXPR (arg_node), arg_node,
		   "attribute VARDEC_EXPR must be NULL");
    }

/*
 * Son check: VARDEC_TYPE 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (VARDEC_TYPE (arg_node), arg_node,
		   "mandatory son VARDEC_TYPE is NULL");
      if (VARDEC_TYPE (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (VARDEC_TYPE (arg_node)) == N_type)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDEC_TYPE hasnt the right type."
					 " It should be: " "N_type");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDEC_TYPE (arg_node), arg_node,
		   "attribute VARDEC_TYPE must be NULL");
    }

/*
 * Son check: VARDEC_VAR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (VARDEC_VAR (arg_node), arg_node,
		   "mandatory son VARDEC_VAR is NULL");
      if (VARDEC_VAR (arg_node) != NULL)
	{
	  if (!((FALSE) || (NODE_TYPE (VARDEC_VAR (arg_node)) == N_var)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDEC_VAR hasnt the right type."
					 " It should be: " "N_var");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDEC_VAR (arg_node), arg_node,
		   "attribute VARDEC_VAR must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (VARDEC_EXPR (arg_node) != NULL)
    {
      VARDEC_EXPR (arg_node) = TRAVdo (VARDEC_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (VARDEC_TYPE (arg_node) != NULL)
    {
      VARDEC_TYPE (arg_node) = TRAVdo (VARDEC_TYPE (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (VARDEC_VAR (arg_node) != NULL)
    {
      VARDEC_VAR (arg_node) = TRAVdo (VARDEC_VAR (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvardeclist
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node VarDecList node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvardeclist (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvardeclist");

/*
 * Son check: VARDECLIST_NEXT 
 */
  if ((FALSE) || (TRUE))
    {
      if (VARDECLIST_NEXT (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (VARDECLIST_NEXT (arg_node)) == N_vardeclist)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDECLIST_NEXT hasnt the right type."
					 " It should be: " "N_vardeclist");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDECLIST_NEXT (arg_node), arg_node,
		   "attribute VARDECLIST_NEXT must be NULL");
    }

/*
 * Son check: VARDECLIST_VARDEC 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (VARDECLIST_VARDEC (arg_node), arg_node,
		   "mandatory son VARDECLIST_VARDEC is NULL");
      if (VARDECLIST_VARDEC (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (VARDECLIST_VARDEC (arg_node)) == N_vardec)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "VARDECLIST_VARDEC hasnt the right type."
					 " It should be: " "N_vardec");
	    }
	}
    }
  else
    {
      CHKnotExist (VARDECLIST_VARDEC (arg_node), arg_node,
		   "attribute VARDECLIST_VARDEC must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (VARDECLIST_NEXT (arg_node) != NULL)
    {
      VARDECLIST_NEXT (arg_node) =
	TRAVdo (VARDECLIST_NEXT (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (VARDECLIST_VARDEC (arg_node) != NULL)
    {
      VARDECLIST_VARDEC (arg_node) =
	TRAVdo (VARDECLIST_VARDEC (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKvarlet
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node VarLet node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKvarlet (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKvarlet");

/*
 * Attribute check: VARLET_DECL
 */
  if ((FALSE) || (TRUE))
    {
    }
  else
    {
      CHKnotExist (VARLET_DECL (arg_node), arg_node,
		   "attribute VARLET_DECL must be NULL");
    }

/*
 * Attribute check: VARLET_NAME
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistAttribute (VARLET_NAME (arg_node), arg_node,
			 "mandatory attribute VARLET_NAME is NULL");
    }
  else
    {
      CHKnotExist (VARLET_NAME (arg_node), arg_node,
		   "attribute VARLET_NAME must be NULL");
    }
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKwhile
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node While node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKwhile (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKwhile");
  DBUG_RETURN (arg_node);
}

/** <!--******************************************************************-->
 *
 * @fn CHKwhilestat
 *
 * @brief Check the node and its sons/attributes
 *
 * @param arg_node WhileStat node to process
 * @param arg_info pointer to info structure
 *
 * @return processed node
 *
 ***************************************************************************/
node *
CHKwhilestat (node * arg_node, info * arg_info)
{
  DBUG_ENTER ("CHKwhilestat");

/*
 * Son check: WHILESTAT_BLOCK 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (WHILESTAT_BLOCK (arg_node), arg_node,
		   "mandatory son WHILESTAT_BLOCK is NULL");
      if (WHILESTAT_BLOCK (arg_node) != NULL)
	{
	  if (!((FALSE) || (isBlock (WHILESTAT_BLOCK (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "WHILESTAT_BLOCK hasnt the right type."
					 " It should be: " "Nodeset: Block");
	    }
	}
    }
  else
    {
      CHKnotExist (WHILESTAT_BLOCK (arg_node), arg_node,
		   "attribute WHILESTAT_BLOCK must be NULL");
    }

/*
 * Son check: WHILESTAT_EXPR 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (WHILESTAT_EXPR (arg_node), arg_node,
		   "mandatory son WHILESTAT_EXPR is NULL");
      if (WHILESTAT_EXPR (arg_node) != NULL)
	{
	  if (!((FALSE) || (isExpr (WHILESTAT_EXPR (arg_node)))))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "WHILESTAT_EXPR hasnt the right type."
					 " It should be: " "Nodeset: Expr");
	    }
	}
    }
  else
    {
      CHKnotExist (WHILESTAT_EXPR (arg_node), arg_node,
		   "attribute WHILESTAT_EXPR must be NULL");
    }

/*
 * Son check: WHILESTAT_WHILE 
 */
  if ((FALSE) || (TRUE))
    {
      CHKexistSon (WHILESTAT_WHILE (arg_node), arg_node,
		   "mandatory son WHILESTAT_WHILE is NULL");
      if (WHILESTAT_WHILE (arg_node) != NULL)
	{
	  if (!
	      ((FALSE)
	       || (NODE_TYPE (WHILESTAT_WHILE (arg_node)) == N_while)))
	    {
	      CHKcorrectTypeInsertError (arg_node,
					 "WHILESTAT_WHILE hasnt the right type."
					 " It should be: " "N_while");
	    }
	}
    }
  else
    {
      CHKnotExist (WHILESTAT_WHILE (arg_node), arg_node,
		   "attribute WHILESTAT_WHILE must be NULL");
    }

/*
 * trav functions: to get all sons
 */
  if (WHILESTAT_BLOCK (arg_node) != NULL)
    {
      WHILESTAT_BLOCK (arg_node) =
	TRAVdo (WHILESTAT_BLOCK (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (WHILESTAT_EXPR (arg_node) != NULL)
    {
      WHILESTAT_EXPR (arg_node) =
	TRAVdo (WHILESTAT_EXPR (arg_node), arg_info);
    }

/*
 * trav functions: to get all sons
 */
  if (WHILESTAT_WHILE (arg_node) != NULL)
    {
      WHILESTAT_WHILE (arg_node) =
	TRAVdo (WHILESTAT_WHILE (arg_node), arg_info);
    }
  DBUG_RETURN (arg_node);
}

typedef enum
{ CHK_binop_op,
  CHK_bool_value,
  CHK_do_value,
  CHK_else_value,
  CHK_equals_value,
  CHK_error_message,
  CHK_export_value,
  CHK_extern_value,
  CHK_float_value,
  CHK_for_value,
  CHK_ifkeyword_value,
  CHK_key_bool_value,
  CHK_key_float_value,
  CHK_key_int_value,
  CHK_key_void_value,
  CHK_l_bracket_value,
  CHK_l_fl_bracket_value,
  CHK_monop_op,
  CHK_num_value,
  CHK_r_bracket_value,
  CHK_r_fl_bracket_value,
  CHK_returnkeyword_value,
  CHK_var_name,
  CHK_varlet_name,
  CHK_while_value,
} attr_list;
