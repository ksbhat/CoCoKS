
/**
 * @file node_basic.c
 *
 * Functions to allocate node structures
 * 
 * THIS FILE HAS BEEN GENERATED USING 
 * $Id: node_basic.c.xsl 14593 2006-01-31 17:09:55Z cg $.
 * DO NOT EDIT THIS FILE AS MIGHT BE CHANGED IN A LATER VERSION.
 *
 * ALL CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN!
 *
 */

#include "node_basic.h"
#include "tree_basic.h"
#include "memory.h"
#include "dbug.h"
#include "globals.h"
#include "ctinfo.h"

static node *
MakeEmptyNode ()
{
  node *result;

  DBUG_ENTER ("MakeEmptyNode");

  result = (node *) MEMmalloc (sizeof (node));

  NODE_LINE (result) = global.line;

  DBUG_RETURN (result);
}



/*****************************************************************************
 * N_Const :
 *****************************************************************************/

node *
TBmakeConst (node * Set_Const)
{
  node *this;
  DBUG_ENTER ("TBmakeConst");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_const;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_const = MEMmalloc (sizeof (struct SONS_N_CONST));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_const = MEMmalloc (sizeof (struct ATTRIBS_N_CONST));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_const;
  DBUG_PRINT ("MAKE",
	      ("assigning son Set_Const initial value: %s ", Set_Const));
  CONST_SET_CONST (this) = Set_Const;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((CONST_SET_CONST (this) != NULL)
      && (NODE_TYPE (CONST_SET_CONST (this)) != N_num)
      && (NODE_TYPE (CONST_SET_CONST (this)) != N_float)
      && (NODE_TYPE (CONST_SET_CONST (this)) != N_bool))
    {
      CTIwarn
	("Field Set_Const of node N_Const has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Statement :
 *****************************************************************************/

node *
TBmakeStatement (node * Set_Statement)
{
  node *this;
  DBUG_ENTER ("TBmakeStatement");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_statement;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_statement = MEMmalloc (sizeof (struct SONS_N_STATEMENT));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_statement = MEMmalloc (sizeof (struct ATTRIBS_N_STATEMENT));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_statement;
  DBUG_PRINT ("MAKE",
	      ("assigning son Set_Statement initial value: %s ",
	       Set_Statement));
  STATEMENT_SET_STATEMENT (this) = Set_Statement;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((STATEMENT_SET_STATEMENT (this) != NULL)
      && (NODE_TYPE (STATEMENT_SET_STATEMENT (this)) != N_assign)
      && (NODE_TYPE (STATEMENT_SET_STATEMENT (this)) != N_funcall)
      && (NODE_TYPE (STATEMENT_SET_STATEMENT (this)) != N_ifstat)
      && (NODE_TYPE (STATEMENT_SET_STATEMENT (this)) != N_dowhilestat)
      && (NODE_TYPE (STATEMENT_SET_STATEMENT (this)) != N_whilestat)
      && (NODE_TYPE (STATEMENT_SET_STATEMENT (this)) != N_forstat))
    {
      CTIwarn
	("Field Set_Statement of node N_Statement has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Program :
 *****************************************************************************/

node *
TBmakeProgram (node * CodeBlock, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeProgram");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_program;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_program = MEMmalloc (sizeof (struct SONS_N_PROGRAM));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_program = MEMmalloc (sizeof (struct ATTRIBS_N_PROGRAM));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_program;
  DBUG_PRINT ("MAKE",
	      ("assigning son CodeBlock initial value: %s ", CodeBlock));
  PROGRAM_CODEBLOCK (this) = CodeBlock;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  PROGRAM_NEXT (this) = Next;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((PROGRAM_CODEBLOCK (this) != NULL)
      && (NODE_TYPE (PROGRAM_CODEBLOCK (this)) != N_fundec)
      && (NODE_TYPE (PROGRAM_CODEBLOCK (this)) != N_fundef)
      && (NODE_TYPE (PROGRAM_CODEBLOCK (this)) != N_globaldec)
      && (NODE_TYPE (PROGRAM_CODEBLOCK (this)) != N_globaldef))
    {
      CTIwarn
	("Field CodeBlock of node N_Program has non-allowed target node.");
    }
  if ((PROGRAM_NEXT (this) != NULL)
      && (NODE_TYPE (PROGRAM_NEXT (this)) != N_program))
    {
      CTIwarn ("Field Next of node N_Program has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_VarDec :
 *****************************************************************************/

node *
TBmakeVardec (node * Type, node * Var, node * Expr)
{
  node *this;
  DBUG_ENTER ("TBmakeVardec");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_vardec;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_vardec = MEMmalloc (sizeof (struct SONS_N_VARDEC));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_vardec = MEMmalloc (sizeof (struct ATTRIBS_N_VARDEC));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_vardec;
  DBUG_PRINT ("MAKE", ("assigning son Type initial value: %s ", Type));
  VARDEC_TYPE (this) = Type;
  DBUG_PRINT ("MAKE", ("assigning son Var initial value: %s ", Var));
  VARDEC_VAR (this) = Var;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  VARDEC_EXPR (this) = Expr;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((VARDEC_TYPE (this) != NULL)
      && (NODE_TYPE (VARDEC_TYPE (this)) != N_type))
    {
      CTIwarn ("Field Type of node N_VarDec has non-allowed target node.");
    }
  if ((VARDEC_VAR (this) != NULL) && (NODE_TYPE (VARDEC_VAR (this)) != N_var))
    {
      CTIwarn ("Field Var of node N_VarDec has non-allowed target node.");
    }
  if ((VARDEC_EXPR (this) != NULL)
      && (NODE_TYPE (VARDEC_EXPR (this)) != N_binop)
      && (NODE_TYPE (VARDEC_EXPR (this)) != N_monop)
      && (NODE_TYPE (VARDEC_EXPR (this)) != N_cast)
      && (NODE_TYPE (VARDEC_EXPR (this)) != N_var)
      && (NODE_TYPE (VARDEC_EXPR (this)) != N_funcall)
      && (NODE_TYPE (VARDEC_EXPR (this)) != N_const)
      && (NODE_TYPE (VARDEC_EXPR (this)) != N_enclosedexpr))
    {
      CTIwarn ("Field Expr of node N_VarDec has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Param :
 *****************************************************************************/

node *
TBmakeParam (node * Type, node * Var)
{
  node *this;
  DBUG_ENTER ("TBmakeParam");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_param;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_param = MEMmalloc (sizeof (struct SONS_N_PARAM));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_param = MEMmalloc (sizeof (struct ATTRIBS_N_PARAM));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_param;
  DBUG_PRINT ("MAKE", ("assigning son Type initial value: %s ", Type));
  PARAM_TYPE (this) = Type;
  DBUG_PRINT ("MAKE", ("assigning son Var initial value: %s ", Var));
  PARAM_VAR (this) = Var;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((PARAM_TYPE (this) != NULL)
      && (NODE_TYPE (PARAM_TYPE (this)) != N_type))
    {
      CTIwarn ("Field Type of node N_Param has non-allowed target node.");
    }
  if ((PARAM_VAR (this) != NULL) && (NODE_TYPE (PARAM_VAR (this)) != N_var))
    {
      CTIwarn ("Field Var of node N_Param has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Type :
 *****************************************************************************/

node *
TBmakeType (node * Set_Type)
{
  node *this;
  DBUG_ENTER ("TBmakeType");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_type;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_type = MEMmalloc (sizeof (struct SONS_N_TYPE));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_type = MEMmalloc (sizeof (struct ATTRIBS_N_TYPE));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_type;
  DBUG_PRINT ("MAKE",
	      ("assigning son Set_Type initial value: %s ", Set_Type));
  TYPE_SET_TYPE (this) = Set_Type;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((TYPE_SET_TYPE (this) != NULL)
      && (NODE_TYPE (TYPE_SET_TYPE (this)) != N_key_int)
      && (NODE_TYPE (TYPE_SET_TYPE (this)) != N_key_float)
      && (NODE_TYPE (TYPE_SET_TYPE (this)) != N_key_bool))
    {
      CTIwarn ("Field Set_Type of node N_Type has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Extern :
 *****************************************************************************/

node *
TBmakeExtern (keyword Value)
{
  node *this;
  DBUG_ENTER ("TBmakeExtern");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_extern;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_extern = MEMmalloc (sizeof (struct SONS_N_EXTERN));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_extern = MEMmalloc (sizeof (struct ATTRIBS_N_EXTERN));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_extern;
  EXTERN_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Export :
 *****************************************************************************/

node *
TBmakeExport (keyword Value)
{
  node *this;
  DBUG_ENTER ("TBmakeExport");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_export;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_export = MEMmalloc (sizeof (struct SONS_N_EXPORT));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_export = MEMmalloc (sizeof (struct ATTRIBS_N_EXPORT));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_export;
  EXPORT_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_For :
 *****************************************************************************/

node *
TBmakeFor (keyword Value)
{
  node *this;
  DBUG_ENTER ("TBmakeFor");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_for;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_for = MEMmalloc (sizeof (struct SONS_N_FOR));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_for = MEMmalloc (sizeof (struct ATTRIBS_N_FOR));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_for;
  FOR_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Equals :
 *****************************************************************************/

node *
TBmakeEquals (keyword Value)
{
  node *this;
  DBUG_ENTER ("TBmakeEquals");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_equals;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_equals = MEMmalloc (sizeof (struct SONS_N_EQUALS));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_equals = MEMmalloc (sizeof (struct ATTRIBS_N_EQUALS));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_equals;
  EQUALS_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_IfKeyword :
 *****************************************************************************/

node *
TBmakeIfkeyword (keyword Value)
{
  node *this;
  DBUG_ENTER ("TBmakeIfkeyword");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_ifkeyword;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_ifkeyword = MEMmalloc (sizeof (struct SONS_N_IFKEYWORD));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_ifkeyword = MEMmalloc (sizeof (struct ATTRIBS_N_IFKEYWORD));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_ifkeyword;
  IFKEYWORD_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_L_FL_Bracket :
 *****************************************************************************/

node *
TBmakeL_fl_bracket (keyword Value)
{
  node *this;
  DBUG_ENTER ("TBmakeL_fl_bracket");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_l_fl_bracket;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_l_fl_bracket = MEMmalloc (sizeof (struct SONS_N_L_FL_BRACKET));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_l_fl_bracket =
    MEMmalloc (sizeof (struct ATTRIBS_N_L_FL_BRACKET));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_l_fl_bracket;
  L_FL_BRACKET_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_R_FL_Bracket :
 *****************************************************************************/

node *
TBmakeR_fl_bracket (keyword Value)
{
  node *this;
  DBUG_ENTER ("TBmakeR_fl_bracket");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_r_fl_bracket;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_r_fl_bracket = MEMmalloc (sizeof (struct SONS_N_R_FL_BRACKET));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_r_fl_bracket =
    MEMmalloc (sizeof (struct ATTRIBS_N_R_FL_BRACKET));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_r_fl_bracket;
  R_FL_BRACKET_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_L_Bracket :
 *****************************************************************************/

node *
TBmakeL_bracket (keyword Value)
{
  node *this;
  DBUG_ENTER ("TBmakeL_bracket");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_l_bracket;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_l_bracket = MEMmalloc (sizeof (struct SONS_N_L_BRACKET));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_l_bracket = MEMmalloc (sizeof (struct ATTRIBS_N_L_BRACKET));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_l_bracket;
  L_BRACKET_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_R_Bracket :
 *****************************************************************************/

node *
TBmakeR_bracket (keyword Value)
{
  node *this;
  DBUG_ENTER ("TBmakeR_bracket");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_r_bracket;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_r_bracket = MEMmalloc (sizeof (struct SONS_N_R_BRACKET));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_r_bracket = MEMmalloc (sizeof (struct ATTRIBS_N_R_BRACKET));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_r_bracket;
  R_BRACKET_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Key_Void :
 *****************************************************************************/

node *
TBmakeKey_void (keyword Value)
{
  node *this;
  DBUG_ENTER ("TBmakeKey_void");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_key_void;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_key_void = MEMmalloc (sizeof (struct SONS_N_KEY_VOID));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_key_void = MEMmalloc (sizeof (struct ATTRIBS_N_KEY_VOID));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_key_void;
  KEY_VOID_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Key_Int :
 *****************************************************************************/

node *
TBmakeKey_int (keyword Value)
{
  node *this;
  DBUG_ENTER ("TBmakeKey_int");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_key_int;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_key_int = MEMmalloc (sizeof (struct SONS_N_KEY_INT));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_key_int = MEMmalloc (sizeof (struct ATTRIBS_N_KEY_INT));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_key_int;
  KEY_INT_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Key_Float :
 *****************************************************************************/

node *
TBmakeKey_float (keyword Value)
{
  node *this;
  DBUG_ENTER ("TBmakeKey_float");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_key_float;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_key_float = MEMmalloc (sizeof (struct SONS_N_KEY_FLOAT));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_key_float = MEMmalloc (sizeof (struct ATTRIBS_N_KEY_FLOAT));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_key_float;
  KEY_FLOAT_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Key_Bool :
 *****************************************************************************/

node *
TBmakeKey_bool (keyword Value)
{
  node *this;
  DBUG_ENTER ("TBmakeKey_bool");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_key_bool;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_key_bool = MEMmalloc (sizeof (struct SONS_N_KEY_BOOL));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_key_bool = MEMmalloc (sizeof (struct ATTRIBS_N_KEY_BOOL));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_key_bool;
  KEY_BOOL_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunDec :
 *****************************************************************************/

node *
TBmakeFundec (node * Extern, node * FunHeader)
{
  node *this;
  DBUG_ENTER ("TBmakeFundec");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_fundec;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_fundec = MEMmalloc (sizeof (struct SONS_N_FUNDEC));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_fundec = MEMmalloc (sizeof (struct ATTRIBS_N_FUNDEC));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_fundec;
  DBUG_PRINT ("MAKE", ("assigning son Extern initial value: %s ", Extern));
  FUNDEC_EXTERN (this) = Extern;
  DBUG_PRINT ("MAKE",
	      ("assigning son FunHeader initial value: %s ", FunHeader));
  FUNDEC_FUNHEADER (this) = FunHeader;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNDEC_EXTERN (this) != NULL)
      && (NODE_TYPE (FUNDEC_EXTERN (this)) != N_extern))
    {
      CTIwarn ("Field Extern of node N_FunDec has non-allowed target node.");
    }
  if ((FUNDEC_FUNHEADER (this) != NULL)
      && (NODE_TYPE (FUNDEC_FUNHEADER (this)) != N_funheader))
    {
      CTIwarn
	("Field FunHeader of node N_FunDec has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunHeader :
 *****************************************************************************/

node *
TBmakeFunheader (node * RetType, node * Var, node * ParamList)
{
  node *this;
  DBUG_ENTER ("TBmakeFunheader");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_funheader;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_funheader = MEMmalloc (sizeof (struct SONS_N_FUNHEADER));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_funheader = MEMmalloc (sizeof (struct ATTRIBS_N_FUNHEADER));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_funheader;
  DBUG_PRINT ("MAKE", ("assigning son RetType initial value: %s ", RetType));
  FUNHEADER_RETTYPE (this) = RetType;
  DBUG_PRINT ("MAKE", ("assigning son Var initial value: %s ", Var));
  FUNHEADER_VAR (this) = Var;
  DBUG_PRINT ("MAKE",
	      ("assigning son ParamList initial value: %s ", ParamList));
  FUNHEADER_PARAMLIST (this) = ParamList;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNHEADER_RETTYPE (this) != NULL)
      && (NODE_TYPE (FUNHEADER_RETTYPE (this)) != N_rettype))
    {
      CTIwarn
	("Field RetType of node N_FunHeader has non-allowed target node.");
    }
  if ((FUNHEADER_VAR (this) != NULL)
      && (NODE_TYPE (FUNHEADER_VAR (this)) != N_var))
    {
      CTIwarn ("Field Var of node N_FunHeader has non-allowed target node.");
    }
  if ((FUNHEADER_PARAMLIST (this) != NULL)
      && (NODE_TYPE (FUNHEADER_PARAMLIST (this)) != N_paramlist))
    {
      CTIwarn
	("Field ParamList of node N_FunHeader has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_RetType :
 *****************************************************************************/

node *
TBmakeRettype (node * Set_RetType)
{
  node *this;
  DBUG_ENTER ("TBmakeRettype");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_rettype;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_rettype = MEMmalloc (sizeof (struct SONS_N_RETTYPE));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_rettype = MEMmalloc (sizeof (struct ATTRIBS_N_RETTYPE));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_rettype;
  DBUG_PRINT ("MAKE",
	      ("assigning son Set_RetType initial value: %s ", Set_RetType));
  RETTYPE_SET_RETTYPE (this) = Set_RetType;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((RETTYPE_SET_RETTYPE (this) != NULL)
      && (NODE_TYPE (RETTYPE_SET_RETTYPE (this)) != N_key_void)
      && (NODE_TYPE (RETTYPE_SET_RETTYPE (this)) != N_key_int)
      && (NODE_TYPE (RETTYPE_SET_RETTYPE (this)) != N_key_float)
      && (NODE_TYPE (RETTYPE_SET_RETTYPE (this)) != N_key_bool))
    {
      CTIwarn
	("Field Set_RetType of node N_RetType has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_ParamList :
 *****************************************************************************/

node *
TBmakeParamlist (node * Param, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeParamlist");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_paramlist;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_paramlist = MEMmalloc (sizeof (struct SONS_N_PARAMLIST));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_paramlist = MEMmalloc (sizeof (struct ATTRIBS_N_PARAMLIST));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_paramlist;
  DBUG_PRINT ("MAKE", ("assigning son Param initial value: %s ", Param));
  PARAMLIST_PARAM (this) = Param;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  PARAMLIST_NEXT (this) = Next;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((PARAMLIST_PARAM (this) != NULL)
      && (NODE_TYPE (PARAMLIST_PARAM (this)) != N_param))
    {
      CTIwarn
	("Field Param of node N_ParamList has non-allowed target node.");
    }
  if ((PARAMLIST_NEXT (this) != NULL)
      && (NODE_TYPE (PARAMLIST_NEXT (this)) != N_paramlist))
    {
      CTIwarn ("Field Next of node N_ParamList has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunDef :
 *****************************************************************************/

node *
TBmakeFundef (node * Export, node * FunHeader, node * FunBody)
{
  node *this;
  DBUG_ENTER ("TBmakeFundef");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_fundef;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_fundef = MEMmalloc (sizeof (struct SONS_N_FUNDEF));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_fundef = MEMmalloc (sizeof (struct ATTRIBS_N_FUNDEF));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_fundef;
  DBUG_PRINT ("MAKE", ("assigning son Export initial value: %s ", Export));
  FUNDEF_EXPORT (this) = Export;
  DBUG_PRINT ("MAKE",
	      ("assigning son FunHeader initial value: %s ", FunHeader));
  FUNDEF_FUNHEADER (this) = FunHeader;
  DBUG_PRINT ("MAKE", ("assigning son FunBody initial value: %s ", FunBody));
  FUNDEF_FUNBODY (this) = FunBody;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNDEF_EXPORT (this) != NULL)
      && (NODE_TYPE (FUNDEF_EXPORT (this)) != N_export))
    {
      CTIwarn ("Field Export of node N_FunDef has non-allowed target node.");
    }
  if ((FUNDEF_FUNHEADER (this) != NULL)
      && (NODE_TYPE (FUNDEF_FUNHEADER (this)) != N_funheader))
    {
      CTIwarn
	("Field FunHeader of node N_FunDef has non-allowed target node.");
    }
  if ((FUNDEF_FUNBODY (this) != NULL)
      && (NODE_TYPE (FUNDEF_FUNBODY (this)) != N_funbody))
    {
      CTIwarn ("Field FunBody of node N_FunDef has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunBody :
 *****************************************************************************/

node *
TBmakeFunbody ()
{
  node *this;
  DBUG_ENTER ("TBmakeFunbody");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_funbody;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_funbody = MEMmalloc (sizeof (struct SONS_N_FUNBODY));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_funbody = MEMmalloc (sizeof (struct ATTRIBS_N_FUNBODY));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_funbody;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_GlobalDef :
 *****************************************************************************/

node *
TBmakeGlobaldef (node * Export, node * Type, node * Var, node * Expr)
{
  node *this;
  DBUG_ENTER ("TBmakeGlobaldef");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_globaldef;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_globaldef = MEMmalloc (sizeof (struct SONS_N_GLOBALDEF));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_globaldef = MEMmalloc (sizeof (struct ATTRIBS_N_GLOBALDEF));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_globaldef;
  DBUG_PRINT ("MAKE", ("assigning son Export initial value: %s ", Export));
  GLOBALDEF_EXPORT (this) = Export;
  DBUG_PRINT ("MAKE", ("assigning son Type initial value: %s ", Type));
  GLOBALDEF_TYPE (this) = Type;
  DBUG_PRINT ("MAKE", ("assigning son Var initial value: %s ", Var));
  GLOBALDEF_VAR (this) = Var;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  GLOBALDEF_EXPR (this) = Expr;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((GLOBALDEF_EXPORT (this) != NULL)
      && (NODE_TYPE (GLOBALDEF_EXPORT (this)) != N_export))
    {
      CTIwarn
	("Field Export of node N_GlobalDef has non-allowed target node.");
    }
  if ((GLOBALDEF_TYPE (this) != NULL)
      && (NODE_TYPE (GLOBALDEF_TYPE (this)) != N_type))
    {
      CTIwarn ("Field Type of node N_GlobalDef has non-allowed target node.");
    }
  if ((GLOBALDEF_VAR (this) != NULL)
      && (NODE_TYPE (GLOBALDEF_VAR (this)) != N_var))
    {
      CTIwarn ("Field Var of node N_GlobalDef has non-allowed target node.");
    }
  if ((GLOBALDEF_EXPR (this) != NULL)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_binop)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_monop)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_cast)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_var)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_funcall)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_const)
      && (NODE_TYPE (GLOBALDEF_EXPR (this)) != N_enclosedexpr))
    {
      CTIwarn ("Field Expr of node N_GlobalDef has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_GlobalDec :
 *****************************************************************************/

node *
TBmakeGlobaldec (node * Extern, node * Type, node * Var)
{
  node *this;
  DBUG_ENTER ("TBmakeGlobaldec");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_globaldec;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_globaldec = MEMmalloc (sizeof (struct SONS_N_GLOBALDEC));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_globaldec = MEMmalloc (sizeof (struct ATTRIBS_N_GLOBALDEC));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_globaldec;
  DBUG_PRINT ("MAKE", ("assigning son Extern initial value: %s ", Extern));
  GLOBALDEC_EXTERN (this) = Extern;
  DBUG_PRINT ("MAKE", ("assigning son Type initial value: %s ", Type));
  GLOBALDEC_TYPE (this) = Type;
  DBUG_PRINT ("MAKE", ("assigning son Var initial value: %s ", Var));
  GLOBALDEC_VAR (this) = Var;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((GLOBALDEC_EXTERN (this) != NULL)
      && (NODE_TYPE (GLOBALDEC_EXTERN (this)) != N_extern))
    {
      CTIwarn
	("Field Extern of node N_GlobalDec has non-allowed target node.");
    }
  if ((GLOBALDEC_TYPE (this) != NULL)
      && (NODE_TYPE (GLOBALDEC_TYPE (this)) != N_type))
    {
      CTIwarn ("Field Type of node N_GlobalDec has non-allowed target node.");
    }
  if ((GLOBALDEC_VAR (this) != NULL)
      && (NODE_TYPE (GLOBALDEC_VAR (this)) != N_var))
    {
      CTIwarn ("Field Var of node N_GlobalDec has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_VarDecList :
 *****************************************************************************/

node *
TBmakeVardeclist (node * VarDec, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeVardeclist");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_vardeclist;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_vardeclist = MEMmalloc (sizeof (struct SONS_N_VARDECLIST));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_vardeclist =
    MEMmalloc (sizeof (struct ATTRIBS_N_VARDECLIST));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_vardeclist;
  DBUG_PRINT ("MAKE", ("assigning son VarDec initial value: %s ", VarDec));
  VARDECLIST_VARDEC (this) = VarDec;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  VARDECLIST_NEXT (this) = Next;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((VARDECLIST_VARDEC (this) != NULL)
      && (NODE_TYPE (VARDECLIST_VARDEC (this)) != N_vardec))
    {
      CTIwarn
	("Field VarDec of node N_VarDecList has non-allowed target node.");
    }
  if ((VARDECLIST_NEXT (this) != NULL)
      && (NODE_TYPE (VARDECLIST_NEXT (this)) != N_vardeclist))
    {
      CTIwarn
	("Field Next of node N_VarDecList has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Return :
 *****************************************************************************/

node *
TBmakeReturn (node * ReturnKeyword, node * Expr)
{
  node *this;
  DBUG_ENTER ("TBmakeReturn");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_return;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_return = MEMmalloc (sizeof (struct SONS_N_RETURN));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_return = MEMmalloc (sizeof (struct ATTRIBS_N_RETURN));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_return;
  DBUG_PRINT ("MAKE",
	      ("assigning son ReturnKeyword initial value: %s ",
	       ReturnKeyword));
  RETURN_RETURNKEYWORD (this) = ReturnKeyword;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  RETURN_EXPR (this) = Expr;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((RETURN_RETURNKEYWORD (this) != NULL)
      && (NODE_TYPE (RETURN_RETURNKEYWORD (this)) != N_returnkeyword))
    {
      CTIwarn
	("Field ReturnKeyword of node N_Return has non-allowed target node.");
    }
  if ((RETURN_EXPR (this) != NULL)
      && (NODE_TYPE (RETURN_EXPR (this)) != N_binop)
      && (NODE_TYPE (RETURN_EXPR (this)) != N_monop)
      && (NODE_TYPE (RETURN_EXPR (this)) != N_cast)
      && (NODE_TYPE (RETURN_EXPR (this)) != N_var)
      && (NODE_TYPE (RETURN_EXPR (this)) != N_funcall)
      && (NODE_TYPE (RETURN_EXPR (this)) != N_const)
      && (NODE_TYPE (RETURN_EXPR (this)) != N_enclosedexpr))
    {
      CTIwarn ("Field Expr of node N_Return has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_ReturnKeyword :
 *****************************************************************************/

node *
TBmakeReturnkeyword (keyword Value)
{
  node *this;
  DBUG_ENTER ("TBmakeReturnkeyword");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_returnkeyword;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_returnkeyword =
    MEMmalloc (sizeof (struct SONS_N_RETURNKEYWORD));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_returnkeyword =
    MEMmalloc (sizeof (struct ATTRIBS_N_RETURNKEYWORD));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_returnkeyword;
  RETURNKEYWORD_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_StatementList :
 *****************************************************************************/

node *
TBmakeStatementlist (node * Statement, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeStatementlist");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_statementlist;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_statementlist =
    MEMmalloc (sizeof (struct SONS_N_STATEMENTLIST));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_statementlist =
    MEMmalloc (sizeof (struct ATTRIBS_N_STATEMENTLIST));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_statementlist;
  DBUG_PRINT ("MAKE",
	      ("assigning son Statement initial value: %s ", Statement));
  STATEMENTLIST_STATEMENT (this) = Statement;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  STATEMENTLIST_NEXT (this) = Next;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((STATEMENTLIST_STATEMENT (this) != NULL))
    {
      CTIwarn
	("Field Statement of node N_StatementList has non-allowed target node.");
    }
  if ((STATEMENTLIST_NEXT (this) != NULL)
      && (NODE_TYPE (STATEMENTLIST_NEXT (this)) != N_statementlist))
    {
      CTIwarn
	("Field Next of node N_StatementList has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_DoWhileStat :
 *****************************************************************************/

node *
TBmakeDowhilestat (node * Do, node * Block, node * While, node * Expr)
{
  node *this;
  DBUG_ENTER ("TBmakeDowhilestat");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_dowhilestat;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_dowhilestat = MEMmalloc (sizeof (struct SONS_N_DOWHILESTAT));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_dowhilestat =
    MEMmalloc (sizeof (struct ATTRIBS_N_DOWHILESTAT));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_dowhilestat;
  DBUG_PRINT ("MAKE", ("assigning son Do initial value: %s ", Do));
  DOWHILESTAT_DO (this) = Do;
  DBUG_PRINT ("MAKE", ("assigning son Block initial value: %s ", Block));
  DOWHILESTAT_BLOCK (this) = Block;
  DBUG_PRINT ("MAKE", ("assigning son While initial value: %s ", While));
  DOWHILESTAT_WHILE (this) = While;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  DOWHILESTAT_EXPR (this) = Expr;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((DOWHILESTAT_DO (this) != NULL)
      && (NODE_TYPE (DOWHILESTAT_DO (this)) != N_do))
    {
      CTIwarn ("Field Do of node N_DoWhileStat has non-allowed target node.");
    }
  if ((DOWHILESTAT_BLOCK (this) != NULL)
      && (NODE_TYPE (DOWHILESTAT_BLOCK (this)) != N_enclosedblock)
      && (NODE_TYPE (DOWHILESTAT_BLOCK (this)) != N_statement))
    {
      CTIwarn
	("Field Block of node N_DoWhileStat has non-allowed target node.");
    }
  if ((DOWHILESTAT_WHILE (this) != NULL)
      && (NODE_TYPE (DOWHILESTAT_WHILE (this)) != N_while))
    {
      CTIwarn
	("Field While of node N_DoWhileStat has non-allowed target node.");
    }
  if ((DOWHILESTAT_EXPR (this) != NULL)
      && (NODE_TYPE (DOWHILESTAT_EXPR (this)) != N_binop)
      && (NODE_TYPE (DOWHILESTAT_EXPR (this)) != N_monop)
      && (NODE_TYPE (DOWHILESTAT_EXPR (this)) != N_cast)
      && (NODE_TYPE (DOWHILESTAT_EXPR (this)) != N_var)
      && (NODE_TYPE (DOWHILESTAT_EXPR (this)) != N_funcall)
      && (NODE_TYPE (DOWHILESTAT_EXPR (this)) != N_const)
      && (NODE_TYPE (DOWHILESTAT_EXPR (this)) != N_enclosedexpr))
    {
      CTIwarn
	("Field Expr of node N_DoWhileStat has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Do :
 *****************************************************************************/

node *
TBmakeDo (keyword Value)
{
  node *this;
  DBUG_ENTER ("TBmakeDo");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_do;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_do = MEMmalloc (sizeof (struct SONS_N_DO));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_do = MEMmalloc (sizeof (struct ATTRIBS_N_DO));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_do;
  DO_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_While :
 *****************************************************************************/

node *
TBmakeWhile (keyword Value)
{
  node *this;
  DBUG_ENTER ("TBmakeWhile");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_while;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_while = MEMmalloc (sizeof (struct SONS_N_WHILE));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_while = MEMmalloc (sizeof (struct ATTRIBS_N_WHILE));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_while;
  WHILE_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_WhileStat :
 *****************************************************************************/

node *
TBmakeWhilestat (node * While, node * Expr, node * Block)
{
  node *this;
  DBUG_ENTER ("TBmakeWhilestat");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_whilestat;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_whilestat = MEMmalloc (sizeof (struct SONS_N_WHILESTAT));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_whilestat = MEMmalloc (sizeof (struct ATTRIBS_N_WHILESTAT));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_whilestat;
  DBUG_PRINT ("MAKE", ("assigning son While initial value: %s ", While));
  WHILESTAT_WHILE (this) = While;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  WHILESTAT_EXPR (this) = Expr;
  DBUG_PRINT ("MAKE", ("assigning son Block initial value: %s ", Block));
  WHILESTAT_BLOCK (this) = Block;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((WHILESTAT_WHILE (this) != NULL)
      && (NODE_TYPE (WHILESTAT_WHILE (this)) != N_while))
    {
      CTIwarn
	("Field While of node N_WhileStat has non-allowed target node.");
    }
  if ((WHILESTAT_EXPR (this) != NULL)
      && (NODE_TYPE (WHILESTAT_EXPR (this)) != N_binop)
      && (NODE_TYPE (WHILESTAT_EXPR (this)) != N_monop)
      && (NODE_TYPE (WHILESTAT_EXPR (this)) != N_cast)
      && (NODE_TYPE (WHILESTAT_EXPR (this)) != N_var)
      && (NODE_TYPE (WHILESTAT_EXPR (this)) != N_funcall)
      && (NODE_TYPE (WHILESTAT_EXPR (this)) != N_const)
      && (NODE_TYPE (WHILESTAT_EXPR (this)) != N_enclosedexpr))
    {
      CTIwarn ("Field Expr of node N_WhileStat has non-allowed target node.");
    }
  if ((WHILESTAT_BLOCK (this) != NULL)
      && (NODE_TYPE (WHILESTAT_BLOCK (this)) != N_enclosedblock)
      && (NODE_TYPE (WHILESTAT_BLOCK (this)) != N_statement))
    {
      CTIwarn
	("Field Block of node N_WhileStat has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_ForStat :
 *****************************************************************************/

node *
TBmakeForstat (node * For, node * ForDec, node * Block)
{
  node *this;
  DBUG_ENTER ("TBmakeForstat");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_forstat;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_forstat = MEMmalloc (sizeof (struct SONS_N_FORSTAT));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_forstat = MEMmalloc (sizeof (struct ATTRIBS_N_FORSTAT));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_forstat;
  DBUG_PRINT ("MAKE", ("assigning son For initial value: %s ", For));
  FORSTAT_FOR (this) = For;
  DBUG_PRINT ("MAKE", ("assigning son ForDec initial value: %s ", ForDec));
  FORSTAT_FORDEC (this) = ForDec;
  DBUG_PRINT ("MAKE", ("assigning son Block initial value: %s ", Block));
  FORSTAT_BLOCK (this) = Block;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FORSTAT_FOR (this) != NULL)
      && (NODE_TYPE (FORSTAT_FOR (this)) != N_for))
    {
      CTIwarn ("Field For of node N_ForStat has non-allowed target node.");
    }
  if ((FORSTAT_FORDEC (this) != NULL))
    {
      CTIwarn ("Field ForDec of node N_ForStat has non-allowed target node.");
    }
  if ((FORSTAT_BLOCK (this) != NULL)
      && (NODE_TYPE (FORSTAT_BLOCK (this)) != N_enclosedblock)
      && (NODE_TYPE (FORSTAT_BLOCK (this)) != N_statement))
    {
      CTIwarn ("Field Block of node N_ForStat has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_ForDec :
 *****************************************************************************/

node *
TBmakeFordec (node * Type, node * ForVarInit, node * Expr)
{
  node *this;
  DBUG_ENTER ("TBmakeFordec");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_fordec;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_fordec = MEMmalloc (sizeof (struct SONS_N_FORDEC));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_fordec = MEMmalloc (sizeof (struct ATTRIBS_N_FORDEC));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_fordec;
  DBUG_PRINT ("MAKE", ("assigning son Type initial value: %s ", Type));
  FORDEC_TYPE (this) = Type;
  DBUG_PRINT ("MAKE",
	      ("assigning son ForVarInit initial value: %s ", ForVarInit));
  FORDEC_FORVARINIT (this) = ForVarInit;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  FORDEC_EXPR (this) = Expr;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FORDEC_TYPE (this) != NULL)
      && (NODE_TYPE (FORDEC_TYPE (this)) != N_type))
    {
      CTIwarn ("Field Type of node N_ForDec has non-allowed target node.");
    }
  if ((FORDEC_FORVARINIT (this) != NULL)
      && (NODE_TYPE (FORDEC_FORVARINIT (this)) != N_forvarinit))
    {
      CTIwarn
	("Field ForVarInit of node N_ForDec has non-allowed target node.");
    }
  if ((FORDEC_EXPR (this) != NULL)
      && (NODE_TYPE (FORDEC_EXPR (this)) != N_binop)
      && (NODE_TYPE (FORDEC_EXPR (this)) != N_monop)
      && (NODE_TYPE (FORDEC_EXPR (this)) != N_cast)
      && (NODE_TYPE (FORDEC_EXPR (this)) != N_var)
      && (NODE_TYPE (FORDEC_EXPR (this)) != N_funcall)
      && (NODE_TYPE (FORDEC_EXPR (this)) != N_const)
      && (NODE_TYPE (FORDEC_EXPR (this)) != N_enclosedexpr))
    {
      CTIwarn ("Field Expr of node N_ForDec has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_ForVarInit :
 *****************************************************************************/

node *
TBmakeForvarinit (node * VarLet, node * Equals, node * Expr)
{
  node *this;
  DBUG_ENTER ("TBmakeForvarinit");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_forvarinit;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_forvarinit = MEMmalloc (sizeof (struct SONS_N_FORVARINIT));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_forvarinit =
    MEMmalloc (sizeof (struct ATTRIBS_N_FORVARINIT));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_forvarinit;
  DBUG_PRINT ("MAKE", ("assigning son VarLet initial value: %s ", VarLet));
  FORVARINIT_VARLET (this) = VarLet;
  DBUG_PRINT ("MAKE", ("assigning son Equals initial value: %s ", Equals));
  FORVARINIT_EQUALS (this) = Equals;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  FORVARINIT_EXPR (this) = Expr;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FORVARINIT_VARLET (this) != NULL)
      && (NODE_TYPE (FORVARINIT_VARLET (this)) != N_varlet))
    {
      CTIwarn
	("Field VarLet of node N_ForVarInit has non-allowed target node.");
    }
  if ((FORVARINIT_EQUALS (this) != NULL)
      && (NODE_TYPE (FORVARINIT_EQUALS (this)) != N_equals))
    {
      CTIwarn
	("Field Equals of node N_ForVarInit has non-allowed target node.");
    }
  if ((FORVARINIT_EXPR (this) != NULL)
      && (NODE_TYPE (FORVARINIT_EXPR (this)) != N_binop)
      && (NODE_TYPE (FORVARINIT_EXPR (this)) != N_monop)
      && (NODE_TYPE (FORVARINIT_EXPR (this)) != N_cast)
      && (NODE_TYPE (FORVARINIT_EXPR (this)) != N_var)
      && (NODE_TYPE (FORVARINIT_EXPR (this)) != N_funcall)
      && (NODE_TYPE (FORVARINIT_EXPR (this)) != N_const)
      && (NODE_TYPE (FORVARINIT_EXPR (this)) != N_enclosedexpr))
    {
      CTIwarn
	("Field Expr of node N_ForVarInit has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_FunCall :
 *****************************************************************************/

node *
TBmakeFuncall (node * Var, node * ExprList)
{
  node *this;
  DBUG_ENTER ("TBmakeFuncall");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_funcall;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_funcall = MEMmalloc (sizeof (struct SONS_N_FUNCALL));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_funcall = MEMmalloc (sizeof (struct ATTRIBS_N_FUNCALL));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_funcall;
  DBUG_PRINT ("MAKE", ("assigning son Var initial value: %s ", Var));
  FUNCALL_VAR (this) = Var;
  DBUG_PRINT ("MAKE",
	      ("assigning son ExprList initial value: %s ", ExprList));
  FUNCALL_EXPRLIST (this) = ExprList;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((FUNCALL_VAR (this) != NULL)
      && (NODE_TYPE (FUNCALL_VAR (this)) != N_var))
    {
      CTIwarn ("Field Var of node N_FunCall has non-allowed target node.");
    }
  if ((FUNCALL_EXPRLIST (this) != NULL)
      && (NODE_TYPE (FUNCALL_EXPRLIST (this)) != N_exprlist))
    {
      CTIwarn
	("Field ExprList of node N_FunCall has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_ExprList :
 *****************************************************************************/

node *
TBmakeExprlist (node * Expr, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeExprlist");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_exprlist;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_exprlist = MEMmalloc (sizeof (struct SONS_N_EXPRLIST));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_exprlist = MEMmalloc (sizeof (struct ATTRIBS_N_EXPRLIST));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_exprlist;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  EXPRLIST_EXPR (this) = Expr;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  EXPRLIST_NEXT (this) = Next;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((EXPRLIST_EXPR (this) != NULL)
      && (NODE_TYPE (EXPRLIST_EXPR (this)) != N_binop)
      && (NODE_TYPE (EXPRLIST_EXPR (this)) != N_monop)
      && (NODE_TYPE (EXPRLIST_EXPR (this)) != N_cast)
      && (NODE_TYPE (EXPRLIST_EXPR (this)) != N_var)
      && (NODE_TYPE (EXPRLIST_EXPR (this)) != N_funcall)
      && (NODE_TYPE (EXPRLIST_EXPR (this)) != N_const)
      && (NODE_TYPE (EXPRLIST_EXPR (this)) != N_enclosedexpr))
    {
      CTIwarn ("Field Expr of node N_ExprList has non-allowed target node.");
    }
  if ((EXPRLIST_NEXT (this) != NULL)
      && (NODE_TYPE (EXPRLIST_NEXT (this)) != N_exprlist))
    {
      CTIwarn ("Field Next of node N_ExprList has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_IfStat :
 *****************************************************************************/

node *
TBmakeIfstat (node * If, node * L_Bracket, node * Expr, node * R_Bracket,
	      node * Block, node * ElseBlock)
{
  node *this;
  DBUG_ENTER ("TBmakeIfstat");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_ifstat;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_ifstat = MEMmalloc (sizeof (struct SONS_N_IFSTAT));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_ifstat = MEMmalloc (sizeof (struct ATTRIBS_N_IFSTAT));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_ifstat;
  DBUG_PRINT ("MAKE", ("assigning son If initial value: %s ", If));
  IFSTAT_IF (this) = If;
  DBUG_PRINT ("MAKE",
	      ("assigning son L_Bracket initial value: %s ", L_Bracket));
  IFSTAT_L_BRACKET (this) = L_Bracket;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  IFSTAT_EXPR (this) = Expr;
  DBUG_PRINT ("MAKE",
	      ("assigning son R_Bracket initial value: %s ", R_Bracket));
  IFSTAT_R_BRACKET (this) = R_Bracket;
  DBUG_PRINT ("MAKE", ("assigning son Block initial value: %s ", Block));
  IFSTAT_BLOCK (this) = Block;
  DBUG_PRINT ("MAKE",
	      ("assigning son ElseBlock initial value: %s ", ElseBlock));
  IFSTAT_ELSEBLOCK (this) = ElseBlock;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((IFSTAT_IF (this) != NULL)
      && (NODE_TYPE (IFSTAT_IF (this)) != N_ifkeyword))
    {
      CTIwarn ("Field If of node N_IfStat has non-allowed target node.");
    }
  if ((IFSTAT_L_BRACKET (this) != NULL)
      && (NODE_TYPE (IFSTAT_L_BRACKET (this)) != N_l_bracket))
    {
      CTIwarn
	("Field L_Bracket of node N_IfStat has non-allowed target node.");
    }
  if ((IFSTAT_EXPR (this) != NULL)
      && (NODE_TYPE (IFSTAT_EXPR (this)) != N_binop)
      && (NODE_TYPE (IFSTAT_EXPR (this)) != N_monop)
      && (NODE_TYPE (IFSTAT_EXPR (this)) != N_cast)
      && (NODE_TYPE (IFSTAT_EXPR (this)) != N_var)
      && (NODE_TYPE (IFSTAT_EXPR (this)) != N_funcall)
      && (NODE_TYPE (IFSTAT_EXPR (this)) != N_const)
      && (NODE_TYPE (IFSTAT_EXPR (this)) != N_enclosedexpr))
    {
      CTIwarn ("Field Expr of node N_IfStat has non-allowed target node.");
    }
  if ((IFSTAT_R_BRACKET (this) != NULL)
      && (NODE_TYPE (IFSTAT_R_BRACKET (this)) != N_r_bracket))
    {
      CTIwarn
	("Field R_Bracket of node N_IfStat has non-allowed target node.");
    }
  if ((IFSTAT_BLOCK (this) != NULL)
      && (NODE_TYPE (IFSTAT_BLOCK (this)) != N_enclosedblock)
      && (NODE_TYPE (IFSTAT_BLOCK (this)) != N_statement))
    {
      CTIwarn ("Field Block of node N_IfStat has non-allowed target node.");
    }
  if ((IFSTAT_ELSEBLOCK (this) != NULL)
      && (NODE_TYPE (IFSTAT_ELSEBLOCK (this)) != N_elseblock))
    {
      CTIwarn
	("Field ElseBlock of node N_IfStat has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_ElseBlock :
 *****************************************************************************/

node *
TBmakeElseblock (node * Else, node * Block)
{
  node *this;
  DBUG_ENTER ("TBmakeElseblock");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_elseblock;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_elseblock = MEMmalloc (sizeof (struct SONS_N_ELSEBLOCK));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_elseblock = MEMmalloc (sizeof (struct ATTRIBS_N_ELSEBLOCK));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_elseblock;
  DBUG_PRINT ("MAKE", ("assigning son Else initial value: %s ", Else));
  ELSEBLOCK_ELSE (this) = Else;
  DBUG_PRINT ("MAKE", ("assigning son Block initial value: %s ", Block));
  ELSEBLOCK_BLOCK (this) = Block;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((ELSEBLOCK_ELSE (this) != NULL)
      && (NODE_TYPE (ELSEBLOCK_ELSE (this)) != N_else))
    {
      CTIwarn ("Field Else of node N_ElseBlock has non-allowed target node.");
    }
  if ((ELSEBLOCK_BLOCK (this) != NULL)
      && (NODE_TYPE (ELSEBLOCK_BLOCK (this)) != N_enclosedblock)
      && (NODE_TYPE (ELSEBLOCK_BLOCK (this)) != N_statement))
    {
      CTIwarn
	("Field Block of node N_ElseBlock has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Else :
 *****************************************************************************/

node *
TBmakeElse (keyword Value)
{
  node *this;
  DBUG_ENTER ("TBmakeElse");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_else;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_else = MEMmalloc (sizeof (struct SONS_N_ELSE));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_else = MEMmalloc (sizeof (struct ATTRIBS_N_ELSE));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_else;
  ELSE_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_EnclosedBlock :
 *****************************************************************************/

node *
TBmakeEnclosedblock (node * L_FL_Bracket, node * StatementList,
		     node * R_FL_Bracket)
{
  node *this;
  DBUG_ENTER ("TBmakeEnclosedblock");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_enclosedblock;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_enclosedblock =
    MEMmalloc (sizeof (struct SONS_N_ENCLOSEDBLOCK));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_enclosedblock =
    MEMmalloc (sizeof (struct ATTRIBS_N_ENCLOSEDBLOCK));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_enclosedblock;
  DBUG_PRINT ("MAKE",
	      ("assigning son L_FL_Bracket initial value: %s ",
	       L_FL_Bracket));
  ENCLOSEDBLOCK_L_FL_BRACKET (this) = L_FL_Bracket;
  DBUG_PRINT ("MAKE",
	      ("assigning son StatementList initial value: %s ",
	       StatementList));
  ENCLOSEDBLOCK_STATEMENTLIST (this) = StatementList;
  DBUG_PRINT ("MAKE",
	      ("assigning son R_FL_Bracket initial value: %s ",
	       R_FL_Bracket));
  ENCLOSEDBLOCK_R_FL_BRACKET (this) = R_FL_Bracket;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((ENCLOSEDBLOCK_L_FL_BRACKET (this) != NULL)
      && (NODE_TYPE (ENCLOSEDBLOCK_L_FL_BRACKET (this)) != N_l_fl_bracket))
    {
      CTIwarn
	("Field L_FL_Bracket of node N_EnclosedBlock has non-allowed target node.");
    }
  if ((ENCLOSEDBLOCK_STATEMENTLIST (this) != NULL)
      && (NODE_TYPE (ENCLOSEDBLOCK_STATEMENTLIST (this)) != N_statementlist))
    {
      CTIwarn
	("Field StatementList of node N_EnclosedBlock has non-allowed target node.");
    }
  if ((ENCLOSEDBLOCK_R_FL_BRACKET (this) != NULL)
      && (NODE_TYPE (ENCLOSEDBLOCK_R_FL_BRACKET (this)) != N_r_fl_bracket))
    {
      CTIwarn
	("Field R_FL_Bracket of node N_EnclosedBlock has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Assign :
 *****************************************************************************/

node *
TBmakeAssign (node * Let, node * Expr)
{
  node *this;
  DBUG_ENTER ("TBmakeAssign");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_assign;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_assign = MEMmalloc (sizeof (struct SONS_N_ASSIGN));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_assign = MEMmalloc (sizeof (struct ATTRIBS_N_ASSIGN));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_assign;
  DBUG_PRINT ("MAKE", ("assigning son Let initial value: %s ", Let));
  ASSIGN_LET (this) = Let;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  ASSIGN_EXPR (this) = Expr;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((ASSIGN_LET (this) != NULL)
      && (NODE_TYPE (ASSIGN_LET (this)) != N_varlet))
    {
      CTIwarn ("Field Let of node N_Assign has non-allowed target node.");
    }
  if ((ASSIGN_EXPR (this) != NULL)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_binop)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_monop)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_cast)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_var)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_funcall)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_const)
      && (NODE_TYPE (ASSIGN_EXPR (this)) != N_enclosedexpr))
    {
      CTIwarn ("Field Expr of node N_Assign has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_BinOp :
 *****************************************************************************/

node *
TBmakeBinop (binop Op, node * Left, node * Right)
{
  node *this;
  DBUG_ENTER ("TBmakeBinop");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_binop;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_binop = MEMmalloc (sizeof (struct SONS_N_BINOP));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_binop = MEMmalloc (sizeof (struct ATTRIBS_N_BINOP));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_binop;
  DBUG_PRINT ("MAKE", ("assigning son Left initial value: %s ", Left));
  BINOP_LEFT (this) = Left;
  DBUG_PRINT ("MAKE", ("assigning son Right initial value: %s ", Right));
  BINOP_RIGHT (this) = Right;
  BINOP_OP (this) = Op;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((BINOP_LEFT (this) != NULL)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_binop)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_monop)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_cast)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_var)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_funcall)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_const)
      && (NODE_TYPE (BINOP_LEFT (this)) != N_enclosedexpr))
    {
      CTIwarn ("Field Left of node N_BinOp has non-allowed target node.");
    }
  if ((BINOP_RIGHT (this) != NULL)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_binop)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_monop)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_cast)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_var)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_funcall)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_const)
      && (NODE_TYPE (BINOP_RIGHT (this)) != N_enclosedexpr))
    {
      CTIwarn ("Field Right of node N_BinOp has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_MonOp :
 *****************************************************************************/

node *
TBmakeMonop (monop Op, node * Right)
{
  node *this;
  DBUG_ENTER ("TBmakeMonop");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_monop;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_monop = MEMmalloc (sizeof (struct SONS_N_MONOP));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_monop = MEMmalloc (sizeof (struct ATTRIBS_N_MONOP));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_monop;
  DBUG_PRINT ("MAKE", ("assigning son Right initial value: %s ", Right));
  MONOP_RIGHT (this) = Right;
  MONOP_OP (this) = Op;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((MONOP_RIGHT (this) != NULL)
      && (NODE_TYPE (MONOP_RIGHT (this)) != N_binop)
      && (NODE_TYPE (MONOP_RIGHT (this)) != N_monop)
      && (NODE_TYPE (MONOP_RIGHT (this)) != N_cast)
      && (NODE_TYPE (MONOP_RIGHT (this)) != N_var)
      && (NODE_TYPE (MONOP_RIGHT (this)) != N_funcall)
      && (NODE_TYPE (MONOP_RIGHT (this)) != N_const)
      && (NODE_TYPE (MONOP_RIGHT (this)) != N_enclosedexpr))
    {
      CTIwarn ("Field Right of node N_MonOp has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Cast :
 *****************************************************************************/

node *
TBmakeCast (node * L_Bracket, node * Type, node * R_Bracket, node * Expr)
{
  node *this;
  DBUG_ENTER ("TBmakeCast");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_cast;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_cast = MEMmalloc (sizeof (struct SONS_N_CAST));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_cast = MEMmalloc (sizeof (struct ATTRIBS_N_CAST));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_cast;
  DBUG_PRINT ("MAKE",
	      ("assigning son L_Bracket initial value: %s ", L_Bracket));
  CAST_L_BRACKET (this) = L_Bracket;
  DBUG_PRINT ("MAKE", ("assigning son Type initial value: %s ", Type));
  CAST_TYPE (this) = Type;
  DBUG_PRINT ("MAKE",
	      ("assigning son R_Bracket initial value: %s ", R_Bracket));
  CAST_R_BRACKET (this) = R_Bracket;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  CAST_EXPR (this) = Expr;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((CAST_L_BRACKET (this) != NULL)
      && (NODE_TYPE (CAST_L_BRACKET (this)) != N_l_bracket))
    {
      CTIwarn ("Field L_Bracket of node N_Cast has non-allowed target node.");
    }
  if ((CAST_TYPE (this) != NULL) && (NODE_TYPE (CAST_TYPE (this)) != N_type))
    {
      CTIwarn ("Field Type of node N_Cast has non-allowed target node.");
    }
  if ((CAST_R_BRACKET (this) != NULL)
      && (NODE_TYPE (CAST_R_BRACKET (this)) != N_r_bracket))
    {
      CTIwarn ("Field R_Bracket of node N_Cast has non-allowed target node.");
    }
  if ((CAST_EXPR (this) != NULL) && (NODE_TYPE (CAST_EXPR (this)) != N_binop)
      && (NODE_TYPE (CAST_EXPR (this)) != N_monop)
      && (NODE_TYPE (CAST_EXPR (this)) != N_cast)
      && (NODE_TYPE (CAST_EXPR (this)) != N_var)
      && (NODE_TYPE (CAST_EXPR (this)) != N_funcall)
      && (NODE_TYPE (CAST_EXPR (this)) != N_const)
      && (NODE_TYPE (CAST_EXPR (this)) != N_enclosedexpr))
    {
      CTIwarn ("Field Expr of node N_Cast has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_EnclosedExpr :
 *****************************************************************************/

node *
TBmakeEnclosedexpr (node * L_Bracket, node * Expr, node * R_Bracket)
{
  node *this;
  DBUG_ENTER ("TBmakeEnclosedexpr");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_enclosedexpr;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_enclosedexpr = MEMmalloc (sizeof (struct SONS_N_ENCLOSEDEXPR));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_enclosedexpr =
    MEMmalloc (sizeof (struct ATTRIBS_N_ENCLOSEDEXPR));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_enclosedexpr;
  DBUG_PRINT ("MAKE",
	      ("assigning son L_Bracket initial value: %s ", L_Bracket));
  ENCLOSEDEXPR_L_BRACKET (this) = L_Bracket;
  DBUG_PRINT ("MAKE", ("assigning son Expr initial value: %s ", Expr));
  ENCLOSEDEXPR_EXPR (this) = Expr;
  DBUG_PRINT ("MAKE",
	      ("assigning son R_Bracket initial value: %s ", R_Bracket));
  ENCLOSEDEXPR_R_BRACKET (this) = R_Bracket;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((ENCLOSEDEXPR_L_BRACKET (this) != NULL)
      && (NODE_TYPE (ENCLOSEDEXPR_L_BRACKET (this)) != N_l_bracket))
    {
      CTIwarn
	("Field L_Bracket of node N_EnclosedExpr has non-allowed target node.");
    }
  if ((ENCLOSEDEXPR_EXPR (this) != NULL)
      && (NODE_TYPE (ENCLOSEDEXPR_EXPR (this)) != N_binop)
      && (NODE_TYPE (ENCLOSEDEXPR_EXPR (this)) != N_monop)
      && (NODE_TYPE (ENCLOSEDEXPR_EXPR (this)) != N_cast)
      && (NODE_TYPE (ENCLOSEDEXPR_EXPR (this)) != N_var)
      && (NODE_TYPE (ENCLOSEDEXPR_EXPR (this)) != N_funcall)
      && (NODE_TYPE (ENCLOSEDEXPR_EXPR (this)) != N_const)
      && (NODE_TYPE (ENCLOSEDEXPR_EXPR (this)) != N_enclosedexpr))
    {
      CTIwarn
	("Field Expr of node N_EnclosedExpr has non-allowed target node.");
    }
  if ((ENCLOSEDEXPR_R_BRACKET (this) != NULL)
      && (NODE_TYPE (ENCLOSEDEXPR_R_BRACKET (this)) != N_r_bracket))
    {
      CTIwarn
	("Field R_Bracket of node N_EnclosedExpr has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_VarLet :
 *****************************************************************************/

node *
TBmakeVarlet (char *Name)
{
  node *this;
  DBUG_ENTER ("TBmakeVarlet");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_varlet;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_varlet = MEMmalloc (sizeof (struct SONS_N_VARLET));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_varlet = MEMmalloc (sizeof (struct ATTRIBS_N_VARLET));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_varlet;
  VARLET_NAME (this) = Name;
  VARLET_DECL (this) = NULL;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Var :
 *****************************************************************************/

node *
TBmakeVar (char *Name)
{
  node *this;
  DBUG_ENTER ("TBmakeVar");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_var;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_var = MEMmalloc (sizeof (struct SONS_N_VAR));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_var = MEMmalloc (sizeof (struct ATTRIBS_N_VAR));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_var;
  VAR_NAME (this) = Name;
  VAR_DECL (this) = NULL;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Num :
 *****************************************************************************/

node *
TBmakeNum (int Value)
{
  node *this;
  DBUG_ENTER ("TBmakeNum");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_num;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_num = MEMmalloc (sizeof (struct SONS_N_NUM));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_num = MEMmalloc (sizeof (struct ATTRIBS_N_NUM));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_num;
  NUM_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Float :
 *****************************************************************************/

node *
TBmakeFloat (float Value)
{
  node *this;
  DBUG_ENTER ("TBmakeFloat");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_float;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_float = MEMmalloc (sizeof (struct SONS_N_FLOAT));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_float = MEMmalloc (sizeof (struct ATTRIBS_N_FLOAT));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_float;
  FLOAT_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Bool :
 *****************************************************************************/

node *
TBmakeBool (bool Value)
{
  node *this;
  DBUG_ENTER ("TBmakeBool");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_bool;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_bool = MEMmalloc (sizeof (struct SONS_N_BOOL));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_bool = MEMmalloc (sizeof (struct ATTRIBS_N_BOOL));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_bool;
  BOOL_VALUE (this) = Value;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

/*****************************************************************************
 * N_Error :
 *****************************************************************************/

node *
TBmakeError (char *message, compiler_phase_t anyphase, node * Next)
{
  node *this;
  DBUG_ENTER ("TBmakeError");
  DBUG_PRINT ("MAKE", ("allocating node structure"));
  this = MakeEmptyNode ();
  NODE_TYPE (this) = N_error;
  DBUG_PRINT ("MAKE", ("address: %s ", this));
  DBUG_PRINT ("MAKE", ("allocating sons structure"));
  this->sons.N_error = MEMmalloc (sizeof (struct SONS_N_ERROR));
  DBUG_PRINT ("MAKE", ("allocating attrib structure"));
  this->attribs.N_error = MEMmalloc (sizeof (struct ATTRIBS_N_ERROR));
  DBUG_PRINT ("MAKE", ("setting node type"));
  NODE_TYPE (this) = N_error;
  DBUG_PRINT ("MAKE", ("assigning son Next initial value: %s ", Next));
  ERROR_NEXT (this) = Next;
  ERROR_MESSAGE (this) = message;
  ERROR_ANYPHASE (this) = anyphase;
#ifndef DBUG_OFF
  DBUG_PRINT ("MAKE", ("doing son target checks"));
  if ((ERROR_NEXT (this) != NULL)
      && (NODE_TYPE (ERROR_NEXT (this)) != N_error))
    {
      CTIwarn ("Field Next of node N_Error has non-allowed target node.");
    }
#endif /* DBUG_OFF */
  DBUG_RETURN (this);
}

  /* end of file */
