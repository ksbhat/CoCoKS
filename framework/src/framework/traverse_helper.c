
/**
 * @file traverse_helper.c
 *
 * Defines the helper function needed by the traversal system
 * 
 * THIS FILE HAS BEEN GENERATED USING 
 * $Id: traverse_helper.c.xsl 14593 2006-01-31 17:09:55Z cg $.
 * DO NOT EDIT THIS FILE AS MIGHT BE CHANGED IN A LATER VERSION.
 *
 * ALL CHANGES MADE TO THIS FILE WILL BE OVERWRITTEN!
 *
 */


#include "traverse_helper.h"
#include "dbug.h"
#include "tree_basic.h"
#include "traverse.h"

#define TRAV( son, info)    if (son != NULL) { son = TRAVdo( son, info); }

node *
TRAVnone (node * arg_node, info * arg_info)
{
  return (arg_node);
}

node *
TRAVerror (node * arg_node, info * arg_info)
{
  DBUG_ASSERT ((FALSE), "Illegal node type found.");

  return (arg_node);
}

node *
TRAVsons (node * arg_node, info * arg_info)
{
  switch (NODE_TYPE (arg_node))
    {
    case N_const:
      TRAV (CONST_SET_CONST (arg_node), arg_info);
      break;
    case N_statement:
      TRAV (STATEMENT_SET_STATEMENT (arg_node), arg_info);
      break;
    case N_program:
      TRAV (PROGRAM_CODEBLOCK (arg_node), arg_info);
      TRAV (PROGRAM_NEXT (arg_node), arg_info);
      break;
    case N_vardec:
      TRAV (VARDEC_TYPE (arg_node), arg_info);
      TRAV (VARDEC_VAR (arg_node), arg_info);
      TRAV (VARDEC_EXPR (arg_node), arg_info);
      break;
    case N_param:
      TRAV (PARAM_TYPE (arg_node), arg_info);
      TRAV (PARAM_VAR (arg_node), arg_info);
      break;
    case N_type:
      TRAV (TYPE_SET_TYPE (arg_node), arg_info);
      break;
    case N_extern:
      break;
    case N_export:
      break;
    case N_for:
      break;
    case N_equals:
      break;
    case N_ifkeyword:
      break;
    case N_l_fl_bracket:
      break;
    case N_r_fl_bracket:
      break;
    case N_l_bracket:
      break;
    case N_r_bracket:
      break;
    case N_key_void:
      break;
    case N_key_int:
      break;
    case N_key_float:
      break;
    case N_key_bool:
      break;
    case N_fundec:
      TRAV (FUNDEC_EXTERN (arg_node), arg_info);
      TRAV (FUNDEC_FUNHEADER (arg_node), arg_info);
      break;
    case N_funheader:
      TRAV (FUNHEADER_RETTYPE (arg_node), arg_info);
      TRAV (FUNHEADER_VAR (arg_node), arg_info);
      TRAV (FUNHEADER_PARAMLIST (arg_node), arg_info);
      break;
    case N_rettype:
      TRAV (RETTYPE_SET_RETTYPE (arg_node), arg_info);
      break;
    case N_paramlist:
      TRAV (PARAMLIST_PARAM (arg_node), arg_info);
      TRAV (PARAMLIST_NEXT (arg_node), arg_info);
      break;
    case N_fundef:
      TRAV (FUNDEF_EXPORT (arg_node), arg_info);
      TRAV (FUNDEF_FUNHEADER (arg_node), arg_info);
      TRAV (FUNDEF_FUNBODY (arg_node), arg_info);
      break;
    case N_funbody:
      break;
    case N_globaldef:
      TRAV (GLOBALDEF_EXPORT (arg_node), arg_info);
      TRAV (GLOBALDEF_TYPE (arg_node), arg_info);
      TRAV (GLOBALDEF_VAR (arg_node), arg_info);
      TRAV (GLOBALDEF_EXPR (arg_node), arg_info);
      break;
    case N_globaldec:
      TRAV (GLOBALDEC_EXTERN (arg_node), arg_info);
      TRAV (GLOBALDEC_TYPE (arg_node), arg_info);
      TRAV (GLOBALDEC_VAR (arg_node), arg_info);
      break;
    case N_vardeclist:
      TRAV (VARDECLIST_VARDEC (arg_node), arg_info);
      TRAV (VARDECLIST_NEXT (arg_node), arg_info);
      break;
    case N_return:
      TRAV (RETURN_RETURNKEYWORD (arg_node), arg_info);
      TRAV (RETURN_EXPR (arg_node), arg_info);
      break;
    case N_returnkeyword:
      break;
    case N_statementlist:
      TRAV (STATEMENTLIST_STATEMENT (arg_node), arg_info);
      TRAV (STATEMENTLIST_NEXT (arg_node), arg_info);
      break;
    case N_dowhilestat:
      TRAV (DOWHILESTAT_DO (arg_node), arg_info);
      TRAV (DOWHILESTAT_BLOCK (arg_node), arg_info);
      TRAV (DOWHILESTAT_WHILE (arg_node), arg_info);
      TRAV (DOWHILESTAT_EXPR (arg_node), arg_info);
      break;
    case N_do:
      break;
    case N_while:
      break;
    case N_whilestat:
      TRAV (WHILESTAT_WHILE (arg_node), arg_info);
      TRAV (WHILESTAT_EXPR (arg_node), arg_info);
      TRAV (WHILESTAT_BLOCK (arg_node), arg_info);
      break;
    case N_forstat:
      TRAV (FORSTAT_FOR (arg_node), arg_info);
      TRAV (FORSTAT_FORDEC (arg_node), arg_info);
      TRAV (FORSTAT_BLOCK (arg_node), arg_info);
      break;
    case N_fordec:
      TRAV (FORDEC_TYPE (arg_node), arg_info);
      TRAV (FORDEC_FORVARINIT (arg_node), arg_info);
      TRAV (FORDEC_EXPR (arg_node), arg_info);
      break;
    case N_forvarinit:
      TRAV (FORVARINIT_VARLET (arg_node), arg_info);
      TRAV (FORVARINIT_EQUALS (arg_node), arg_info);
      TRAV (FORVARINIT_EXPR (arg_node), arg_info);
      break;
    case N_funcall:
      TRAV (FUNCALL_VAR (arg_node), arg_info);
      TRAV (FUNCALL_EXPRLIST (arg_node), arg_info);
      break;
    case N_exprlist:
      TRAV (EXPRLIST_EXPR (arg_node), arg_info);
      TRAV (EXPRLIST_NEXT (arg_node), arg_info);
      break;
    case N_ifstat:
      TRAV (IFSTAT_IF (arg_node), arg_info);
      TRAV (IFSTAT_L_BRACKET (arg_node), arg_info);
      TRAV (IFSTAT_EXPR (arg_node), arg_info);
      TRAV (IFSTAT_R_BRACKET (arg_node), arg_info);
      TRAV (IFSTAT_BLOCK (arg_node), arg_info);
      TRAV (IFSTAT_ELSEBLOCK (arg_node), arg_info);
      break;
    case N_elseblock:
      TRAV (ELSEBLOCK_ELSE (arg_node), arg_info);
      TRAV (ELSEBLOCK_BLOCK (arg_node), arg_info);
      break;
    case N_else:
      break;
    case N_enclosedblock:
      TRAV (ENCLOSEDBLOCK_L_FL_BRACKET (arg_node), arg_info);
      TRAV (ENCLOSEDBLOCK_STATEMENTLIST (arg_node), arg_info);
      TRAV (ENCLOSEDBLOCK_R_FL_BRACKET (arg_node), arg_info);
      break;
    case N_assign:
      TRAV (ASSIGN_LET (arg_node), arg_info);
      TRAV (ASSIGN_EXPR (arg_node), arg_info);
      break;
    case N_binop:
      TRAV (BINOP_LEFT (arg_node), arg_info);
      TRAV (BINOP_RIGHT (arg_node), arg_info);
      break;
    case N_monop:
      TRAV (MONOP_RIGHT (arg_node), arg_info);
      break;
    case N_cast:
      TRAV (CAST_L_BRACKET (arg_node), arg_info);
      TRAV (CAST_TYPE (arg_node), arg_info);
      TRAV (CAST_R_BRACKET (arg_node), arg_info);
      TRAV (CAST_EXPR (arg_node), arg_info);
      break;
    case N_enclosedexpr:
      TRAV (ENCLOSEDEXPR_L_BRACKET (arg_node), arg_info);
      TRAV (ENCLOSEDEXPR_EXPR (arg_node), arg_info);
      TRAV (ENCLOSEDEXPR_R_BRACKET (arg_node), arg_info);
      break;
    case N_varlet:
      break;
    case N_var:
      break;
    case N_num:
      break;
    case N_float:
      break;
    case N_bool:
      break;
    case N_error:
      TRAV (ERROR_NEXT (arg_node), arg_info);
      break;
    default:
      DBUG_ASSERT ((FALSE), "Illegal nodetype found!");
      break;
    }

  return (arg_node);
}

int
TRAVnumSons (node * node)
{
  int result = 0;

  DBUG_ENTER ("TRAVnumSons");

  switch (NODE_TYPE (node))
    {
    case N_const:
      result = 1;
      break;
    case N_statement:
      result = 1;
      break;
    case N_program:
      result = 2;
      break;
    case N_vardec:
      result = 3;
      break;
    case N_param:
      result = 2;
      break;
    case N_type:
      result = 1;
      break;
    case N_extern:
      result = 0;
      break;
    case N_export:
      result = 0;
      break;
    case N_for:
      result = 0;
      break;
    case N_equals:
      result = 0;
      break;
    case N_ifkeyword:
      result = 0;
      break;
    case N_l_fl_bracket:
      result = 0;
      break;
    case N_r_fl_bracket:
      result = 0;
      break;
    case N_l_bracket:
      result = 0;
      break;
    case N_r_bracket:
      result = 0;
      break;
    case N_key_void:
      result = 0;
      break;
    case N_key_int:
      result = 0;
      break;
    case N_key_float:
      result = 0;
      break;
    case N_key_bool:
      result = 0;
      break;
    case N_fundec:
      result = 2;
      break;
    case N_funheader:
      result = 3;
      break;
    case N_rettype:
      result = 1;
      break;
    case N_paramlist:
      result = 2;
      break;
    case N_fundef:
      result = 3;
      break;
    case N_funbody:
      result = 0;
      break;
    case N_globaldef:
      result = 4;
      break;
    case N_globaldec:
      result = 3;
      break;
    case N_vardeclist:
      result = 2;
      break;
    case N_return:
      result = 2;
      break;
    case N_returnkeyword:
      result = 0;
      break;
    case N_statementlist:
      result = 2;
      break;
    case N_dowhilestat:
      result = 4;
      break;
    case N_do:
      result = 0;
      break;
    case N_while:
      result = 0;
      break;
    case N_whilestat:
      result = 3;
      break;
    case N_forstat:
      result = 3;
      break;
    case N_fordec:
      result = 3;
      break;
    case N_forvarinit:
      result = 3;
      break;
    case N_funcall:
      result = 2;
      break;
    case N_exprlist:
      result = 2;
      break;
    case N_ifstat:
      result = 6;
      break;
    case N_elseblock:
      result = 2;
      break;
    case N_else:
      result = 0;
      break;
    case N_enclosedblock:
      result = 3;
      break;
    case N_assign:
      result = 2;
      break;
    case N_binop:
      result = 2;
      break;
    case N_monop:
      result = 1;
      break;
    case N_cast:
      result = 4;
      break;
    case N_enclosedexpr:
      result = 3;
      break;
    case N_varlet:
      result = 0;
      break;
    case N_var:
      result = 0;
      break;
    case N_num:
      result = 0;
      break;
    case N_float:
      result = 0;
      break;
    case N_bool:
      result = 0;
      break;
    case N_error:
      result = 1;
      break;
    default:
      DBUG_ASSERT ((FALSE), "Illegal nodetype found!");
      break;
    }

  DBUG_RETURN (result);
}

node *
TRAVgetSon (int no, node * parent)
{
  node *result = NULL;

  DBUG_ENTER ("TRAVgetSon");

  switch (NODE_TYPE (parent))
    {
    case N_const:
      switch (no)
	{
	case 0:
	  result = CONST_SET_CONST (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_statement:
      switch (no)
	{
	case 0:
	  result = STATEMENT_SET_STATEMENT (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_program:
      switch (no)
	{
	case 0:
	  result = PROGRAM_CODEBLOCK (parent);
	  break;
	case 1:
	  result = PROGRAM_NEXT (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_vardec:
      switch (no)
	{
	case 0:
	  result = VARDEC_TYPE (parent);
	  break;
	case 1:
	  result = VARDEC_VAR (parent);
	  break;
	case 2:
	  result = VARDEC_EXPR (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_param:
      switch (no)
	{
	case 0:
	  result = PARAM_TYPE (parent);
	  break;
	case 1:
	  result = PARAM_VAR (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_type:
      switch (no)
	{
	case 0:
	  result = TYPE_SET_TYPE (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_extern:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_export:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_for:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_equals:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_ifkeyword:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_l_fl_bracket:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_r_fl_bracket:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_l_bracket:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_r_bracket:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_key_void:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_key_int:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_key_float:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_key_bool:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_fundec:
      switch (no)
	{
	case 0:
	  result = FUNDEC_EXTERN (parent);
	  break;
	case 1:
	  result = FUNDEC_FUNHEADER (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_funheader:
      switch (no)
	{
	case 0:
	  result = FUNHEADER_RETTYPE (parent);
	  break;
	case 1:
	  result = FUNHEADER_VAR (parent);
	  break;
	case 2:
	  result = FUNHEADER_PARAMLIST (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_rettype:
      switch (no)
	{
	case 0:
	  result = RETTYPE_SET_RETTYPE (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_paramlist:
      switch (no)
	{
	case 0:
	  result = PARAMLIST_PARAM (parent);
	  break;
	case 1:
	  result = PARAMLIST_NEXT (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_fundef:
      switch (no)
	{
	case 0:
	  result = FUNDEF_EXPORT (parent);
	  break;
	case 1:
	  result = FUNDEF_FUNHEADER (parent);
	  break;
	case 2:
	  result = FUNDEF_FUNBODY (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_funbody:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_globaldef:
      switch (no)
	{
	case 0:
	  result = GLOBALDEF_EXPORT (parent);
	  break;
	case 1:
	  result = GLOBALDEF_TYPE (parent);
	  break;
	case 2:
	  result = GLOBALDEF_VAR (parent);
	  break;
	case 3:
	  result = GLOBALDEF_EXPR (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_globaldec:
      switch (no)
	{
	case 0:
	  result = GLOBALDEC_EXTERN (parent);
	  break;
	case 1:
	  result = GLOBALDEC_TYPE (parent);
	  break;
	case 2:
	  result = GLOBALDEC_VAR (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_vardeclist:
      switch (no)
	{
	case 0:
	  result = VARDECLIST_VARDEC (parent);
	  break;
	case 1:
	  result = VARDECLIST_NEXT (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_return:
      switch (no)
	{
	case 0:
	  result = RETURN_RETURNKEYWORD (parent);
	  break;
	case 1:
	  result = RETURN_EXPR (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_returnkeyword:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_statementlist:
      switch (no)
	{
	case 0:
	  result = STATEMENTLIST_STATEMENT (parent);
	  break;
	case 1:
	  result = STATEMENTLIST_NEXT (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_dowhilestat:
      switch (no)
	{
	case 0:
	  result = DOWHILESTAT_DO (parent);
	  break;
	case 1:
	  result = DOWHILESTAT_BLOCK (parent);
	  break;
	case 2:
	  result = DOWHILESTAT_WHILE (parent);
	  break;
	case 3:
	  result = DOWHILESTAT_EXPR (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_do:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_while:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_whilestat:
      switch (no)
	{
	case 0:
	  result = WHILESTAT_WHILE (parent);
	  break;
	case 1:
	  result = WHILESTAT_EXPR (parent);
	  break;
	case 2:
	  result = WHILESTAT_BLOCK (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_forstat:
      switch (no)
	{
	case 0:
	  result = FORSTAT_FOR (parent);
	  break;
	case 1:
	  result = FORSTAT_FORDEC (parent);
	  break;
	case 2:
	  result = FORSTAT_BLOCK (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_fordec:
      switch (no)
	{
	case 0:
	  result = FORDEC_TYPE (parent);
	  break;
	case 1:
	  result = FORDEC_FORVARINIT (parent);
	  break;
	case 2:
	  result = FORDEC_EXPR (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_forvarinit:
      switch (no)
	{
	case 0:
	  result = FORVARINIT_VARLET (parent);
	  break;
	case 1:
	  result = FORVARINIT_EQUALS (parent);
	  break;
	case 2:
	  result = FORVARINIT_EXPR (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_funcall:
      switch (no)
	{
	case 0:
	  result = FUNCALL_VAR (parent);
	  break;
	case 1:
	  result = FUNCALL_EXPRLIST (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_exprlist:
      switch (no)
	{
	case 0:
	  result = EXPRLIST_EXPR (parent);
	  break;
	case 1:
	  result = EXPRLIST_NEXT (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_ifstat:
      switch (no)
	{
	case 0:
	  result = IFSTAT_IF (parent);
	  break;
	case 1:
	  result = IFSTAT_L_BRACKET (parent);
	  break;
	case 2:
	  result = IFSTAT_EXPR (parent);
	  break;
	case 3:
	  result = IFSTAT_R_BRACKET (parent);
	  break;
	case 4:
	  result = IFSTAT_BLOCK (parent);
	  break;
	case 5:
	  result = IFSTAT_ELSEBLOCK (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_elseblock:
      switch (no)
	{
	case 0:
	  result = ELSEBLOCK_ELSE (parent);
	  break;
	case 1:
	  result = ELSEBLOCK_BLOCK (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_else:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_enclosedblock:
      switch (no)
	{
	case 0:
	  result = ENCLOSEDBLOCK_L_FL_BRACKET (parent);
	  break;
	case 1:
	  result = ENCLOSEDBLOCK_STATEMENTLIST (parent);
	  break;
	case 2:
	  result = ENCLOSEDBLOCK_R_FL_BRACKET (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_assign:
      switch (no)
	{
	case 0:
	  result = ASSIGN_LET (parent);
	  break;
	case 1:
	  result = ASSIGN_EXPR (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_binop:
      switch (no)
	{
	case 0:
	  result = BINOP_LEFT (parent);
	  break;
	case 1:
	  result = BINOP_RIGHT (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_monop:
      switch (no)
	{
	case 0:
	  result = MONOP_RIGHT (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_cast:
      switch (no)
	{
	case 0:
	  result = CAST_L_BRACKET (parent);
	  break;
	case 1:
	  result = CAST_TYPE (parent);
	  break;
	case 2:
	  result = CAST_R_BRACKET (parent);
	  break;
	case 3:
	  result = CAST_EXPR (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_enclosedexpr:
      switch (no)
	{
	case 0:
	  result = ENCLOSEDEXPR_L_BRACKET (parent);
	  break;
	case 1:
	  result = ENCLOSEDEXPR_EXPR (parent);
	  break;
	case 2:
	  result = ENCLOSEDEXPR_R_BRACKET (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_varlet:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_var:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_num:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_float:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_bool:
      switch (no)
	{
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    case N_error:
      switch (no)
	{
	case 0:
	  result = ERROR_NEXT (parent);
	  break;
	default:
	  DBUG_ASSERT ((FALSE), "index out of range!");
	  break;
	}
      break;
    default:
      DBUG_ASSERT ((FALSE), "Illegal nodetype found!");
      break;
    }

  DBUG_RETURN (result);
}
